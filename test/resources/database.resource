*** Settings ***
Documentation       Resource file for Database operations and management
...                 Contains all keywords related to:
...                 ‚Ä¢ Database connection management (PostgreSQL, Oracle, etc.)
...                 ‚Ä¢ SQL script execution and management
...                 ‚Ä¢ Query execution and result processing
...                 ‚Ä¢ Table creation and management
...                 ‚Ä¢ Data counting and validation operations
...                 ‚Ä¢ Database utility functions

# Standard Libraries for database operations
Library             OperatingSystem    # File system operations for SQL scripts
Library             DatabaseLibrary    # Generic database operations
Library             psycopg2    # PostgreSQL driver
Library             pymssql    # SQL Server driver
Library             String    # String operations for SQL processing
Library             Collections    # List and dictionary operations


*** Keywords ***
################## DATABASE CONNECTION MANAGEMENT ##################

Connect to Postgres Database
    [Documentation]    Establishes connection to PostgreSQL database using psycopg2 driver
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ Database connection is successfully established
    ...    ‚Ä¢ PostgreSQL server is accessible at specified host and port
    ...    ‚Ä¢ Database credentials are valid and authenticated
    ...    ‚Ä¢ Database name exists and is accessible
    ...    ‚Ä¢ Connection is ready for SQL operations
    [Arguments]
    ...    ${POSTGRES_DBNAME}
    ...    ${POSTGRES_DBUSER}
    ...    ${POSTGRES_DBPASS}
    ...    ${POSTGRES_HOST}
    ...    ${POSTGRES_DBPORT}=5432

    Log    üîå Connecting to PostgreSQL database...
    Log    üìä Host: ${POSTGRES_HOST}:${POSTGRES_DBPORT}
    Log    üèõÔ∏è Database: ${POSTGRES_DBNAME}
    Log    üë§ User: ${POSTGRES_DBUSER}

    Connect To Database
    ...    psycopg2
    ...    ${POSTGRES_DBNAME}
    ...    ${POSTGRES_DBUSER}
    ...    ${POSTGRES_DBPASS}
    ...    ${POSTGRES_HOST}
    ...    ${POSTGRES_DBPORT}

    Log    ‚úÖ Successfully connected to PostgreSQL database

Connect to Oracle Database
    [Documentation]    Sets up Oracle database connection
    ...    *Arguments:*
    ...    - None (uses environment variables for connection)
    ...    *Example:*
    ...    | Connect to Oracle Database |
    [Arguments]    ${ORACLE_DBNAME}    ${ORACLE_DBUSER}    ${ORACLE_DBPASS}    ${ORACLE_HOST}    ${ORACLE_DBPORT}=1521

    Connect To Database
    ...    oracledb
    ...    ${ORACLE_DBNAME}
    ...    ${ORACLE_DBUSER}
    ...    ${ORACLE_DBPASS}
    ...    ${ORACLE_HOST}
    ...    ${ORACLE_DBPORT}

    Log    ‚úÖ Successfully connected to Oracle database

Connect to SQL Server Database
    [Documentation]    Sets up SQL Server database connection
    ...    *Arguments:*
    ...    - Database connection parameters
    ...    *Example:*
    ...    | Connect to SQL Server Database | TestDB | sa | password | localhost | 1433 |
    [Arguments]    ${SQLSERVER_DBNAME}    ${SQLSERVER_DBUSER}    ${SQLSERVER_DBPASS}    ${SQLSERVER_HOST}    ${SQLSERVER_DBPORT}=1433

    Connect To Database
    ...    pymssql
    ...    ${SQLSERVER_DBNAME}
    ...    ${SQLSERVER_DBUSER}
    ...    ${SQLSERVER_DBPASS}
    ...    ${SQLSERVER_HOST}
    ...    ${SQLSERVER_DBPORT}

    Log    ‚úÖ Successfully connected to SQL Server database

Connect to Database Generic
    [Documentation]    Generic database connection supporting multiple database types
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ Database driver module is available and can be imported
    ...    ‚Ä¢ Database server is accessible at specified host and port
    ...    ‚Ä¢ Database credentials are valid and authenticated
    ...    ‚Ä¢ Database name exists and is accessible
    ...    ‚Ä¢ Connection is ready for SQL operations
    [Arguments]    ${db_module}    ${db_name}    ${db_user}    ${db_pass}    ${db_host}    ${db_port}

    Log    üîå Connecting to ${db_module} database...
    Log    üìä Host: ${db_host}:${db_port}
    Log    üèõÔ∏è Database: ${db_name}
    Log    üë§ User: ${db_user}

    Connect To Database
    ...    ${db_module}
    ...    ${db_name}
    ...    ${db_user}
    ...    ${db_pass}
    ...    ${db_host}
    ...    ${db_port}

    Log    ‚úÖ Successfully connected to ${db_module} database

Disconnect from Database
    [Documentation]    Safely disconnects from current database
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ Database connection is properly closed
    ...    ‚Ä¢ No hanging connections or resource leaks
    ...    ‚Ä¢ Connection cleanup is completed successfully

    Log    üîå Disconnecting from database...
    Disconnect From Database
    Log    ‚úÖ Successfully disconnected from database

Test Database Connection
    [Documentation]    Tests database connection with a simple query
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ Database connection is active and responsive
    ...    ‚Ä¢ Simple query executes successfully
    ...    ‚Ä¢ Database server is functioning properly
    [Arguments]    ${test_query}=SELECT 1

    Log    üîç Testing database connection...

    TRY
        ${result}=    Query    ${test_query}
        Log    ‚úÖ Database connection test passed
        Log    üìä Test query result: ${result}
        RETURN    ${TRUE}
    EXCEPT    AS    ${error}
        Log    ‚ùå Database connection test failed: ${error}
        RETURN    ${FALSE}
    END

################## SQL EXECUTION AND MANAGEMENT ##################

Execute SQL String Safe
    [Documentation]    Safely executes SQL string with error handling
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ SQL statement is properly formatted and valid
    ...    ‚Ä¢ SQL execution completes without syntax errors
    ...    ‚Ä¢ Database permissions allow the operation
    ...    ‚Ä¢ Transaction is properly committed or rolled back
    [Arguments]    ${sql_statement}

    Log    üìù Executing SQL statement...
    Log    üîç SQL: ${sql_statement}

    TRY
        Execute SQL String    ${sql_statement}
        Log    ‚úÖ SQL statement executed successfully
    EXCEPT    AS    ${error}
        Log    ‚ùå SQL execution failed: ${error}
        Fail    SQL execution failed: ${error}
    END

Execute SQL Script From File
    [Documentation]    Executes SQL statements from a script file
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ SQL script file exists and is readable
    ...    ‚Ä¢ All SQL statements in file are valid and execute successfully
    ...    ‚Ä¢ Comments and empty lines are properly handled
    ...    ‚Ä¢ File parsing completes without errors
    ...    ‚Ä¢ All statements are executed in sequence
    [Arguments]    ${script_path}

    # Verify script file exists
    File Should Exist    ${script_path}

    # Read the SQL script
    ${sql_content}=    Get File    ${script_path}
    Log    üìÑ Executing SQL script: ${script_path}

    # Split the script into individual statements
    ${sql_statements}=    Split SQL Script Content    ${sql_content}

    # Execute each statement
    ${executed_count}=    Set Variable    0
    FOR    ${statement}    IN    @{sql_statements}
        ${trimmed_statement}=    Strip String    ${statement}
        IF    '${trimmed_statement}' != '' and not '${trimmed_statement}'.startswith('--')
            Log    üîç Executing: ${trimmed_statement}
            Execute SQL String Safe    ${trimmed_statement}
            ${executed_count}=    Evaluate    ${executed_count} + 1
        END
    END

    Log    ‚úÖ SQL script executed successfully (${executed_count} statements)

Split SQL Script Content
    [Documentation]    Splits SQL script content into individual executable statements
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ SQL content is properly parsed and split
    ...    ‚Ä¢ Comments and empty lines are filtered out
    ...    ‚Ä¢ Each statement is properly formatted for execution
    ...    ‚Ä¢ Statement separation by semicolons works correctly
    [Arguments]    ${sql_content}

    # Remove comments and split by semicolon
    ${lines}=    Split To Lines    ${sql_content}
    ${cleaned_lines}=    Create List

    FOR    ${line}    IN    @{lines}
        ${trimmed_line}=    Strip String    ${line}
        IF    not '${trimmed_line}'.startswith('--') and '${trimmed_line}' != ''
            Append To List    ${cleaned_lines}    ${trimmed_line}
        END
    END

    ${cleaned_sql}=    Catenate    SEPARATOR= ${SPACE}    @{cleaned_lines}
    ${statements}=    Split String    ${cleaned_sql}    ;

    # Filter out empty statements
    ${filtered_statements}=    Create List
    FOR    ${stmt}    IN    @{statements}
        ${trimmed_stmt}=    Strip String    ${stmt}
        IF    '${trimmed_stmt}' != ''
            Append To List    ${filtered_statements}    ${trimmed_stmt}
        END
    END

    Log    üìä Split SQL script into ${filtered_statements.__len__()} statements
    RETURN    ${filtered_statements}

################## QUERY EXECUTION AND RESULT PROCESSING ##################

Execute SQL Query And Get Count
    [Documentation]    Executes a COUNT query and returns the result as integer
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ SQL query executes successfully
    ...    ‚Ä¢ Query returns a valid numeric result
    ...    ‚Ä¢ Result can be converted to integer
    ...    ‚Ä¢ Query syntax is valid for COUNT operations
    [Arguments]    ${sql_query}

    Log    üîç Executing count query: ${sql_query}

    ${result}=    Query    ${sql_query}
    ${count_row}=    Get From List    ${result}    0
    ${count_value}=    Get From List    ${count_row}    0

    Log    üìä Count query result: ${count_value}
    RETURN    ${count_value}

Execute SQL Query And Get Results
    [Documentation]    Executes SQL query and returns all results
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ SQL query executes successfully
    ...    ‚Ä¢ Results are properly formatted and returned
    ...    ‚Ä¢ Query syntax is valid
    ...    ‚Ä¢ Database permissions allow the query
    [Arguments]    ${sql_query}    ${fetch_all}=${TRUE}

    Log    üîç Executing query: ${sql_query}

    TRY
        IF    ${fetch_all}
            ${results}=    Query    ${sql_query}
        ELSE
            ${results}=    Query    ${sql_query}    returnAsDict=${TRUE}
        END

        ${row_count}=    Get Length    ${results}
        Log    üìä Query returned ${row_count} rows
        RETURN    ${results}
    EXCEPT    AS    ${error}
        Log    ‚ùå Query execution failed: ${error}
        Fail    Query execution failed: ${error}
    END

Execute SQL Query And Get Single Value
    [Documentation]    Executes SQL query and returns single scalar value
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ SQL query executes successfully
    ...    ‚Ä¢ Query returns exactly one row and one column
    ...    ‚Ä¢ Result can be extracted as single value
    ...    ‚Ä¢ Query is designed for single value return
    [Arguments]    ${sql_query}

    Log    üîç Executing single value query: ${sql_query}

    ${results}=    Query    ${sql_query}
    ${row_count}=    Get Length    ${results}

    Should Be Equal As Numbers    ${row_count}    1
    ...    Query should return exactly 1 row, but returned ${row_count}

    ${first_row}=    Get From List    ${results}    0
    ${value}=    Get From List    ${first_row}    0

    Log    üìä Single value result: ${value}
    RETURN    ${value}

Check If Table Exists
    [Documentation]    Checks if a table exists in the database
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ Database connection is active
    ...    ‚Ä¢ Table existence query executes successfully
    ...    ‚Ä¢ Returns accurate boolean result
    [Arguments]    ${table_name}    ${schema}=public

    ${query}=    Set Variable
    ...    SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='${schema}' AND table_name='${table_name}'

    ${count}=    Execute SQL Query And Get Count    ${query}
    ${exists}=    Evaluate    ${count} > 0

    IF    ${exists}
        Log    ‚úÖ Table '${table_name}' exists in schema '${schema}'
    ELSE
        Log    ‚ùå Table '${table_name}' does not exist in schema '${schema}'
    END

    RETURN    ${exists}

Get Table Row Count
    [Documentation]    Gets the total number of rows in a table
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ Table exists in the database
    ...    ‚Ä¢ COUNT query executes successfully
    ...    ‚Ä¢ Returns accurate row count as integer
    [Arguments]    ${table_name}

    ${query}=    Set Variable    SELECT COUNT(*) FROM ${table_name}
    ${count}=    Execute SQL Query And Get Count    ${query}

    Log    üìä Table '${table_name}' contains ${count} rows
    RETURN    ${count}

################## TABLE MANAGEMENT OPERATIONS ##################

Create Table From Template
    [Documentation]    Creates table using SQL from template or direct SQL statement
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ SQL statement is valid CREATE TABLE syntax
    ...    ‚Ä¢ Table creation executes successfully
    ...    ‚Ä¢ Table is created with proper schema and constraints
    ...    ‚Ä¢ No SQL syntax or permission errors occur
    [Arguments]    ${sql_query}

    Log    üèóÔ∏è Creating table from template...
    Log    üìù SQL: ${sql_query}

    Execute SQL String Safe    ${sql_query}
    Log    ‚úÖ Table created successfully

Drop Table If Exists
    [Documentation]    Safely drops a table if it exists
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ DROP TABLE operation completes successfully
    ...    ‚Ä¢ No errors if table doesn't exist
    ...    ‚Ä¢ Table and all its data are removed
    [Arguments]    ${table_name}    ${cascade}=${FALSE}

    Log    üóëÔ∏è Dropping table if exists: ${table_name}

    ${cascade_clause}=    Set Variable If    ${cascade}    CASCADE    ${EMPTY}
    ${sql}=    Set Variable    DROP TABLE IF EXISTS ${table_name} ${cascade_clause}

    Execute SQL String Safe    ${sql}
    Log    ‚úÖ Table '${table_name}' dropped successfully

Truncate Table
    [Documentation]    Truncates (empties) a table
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ Table exists before truncation
    ...    ‚Ä¢ TRUNCATE operation completes successfully
    ...    ‚Ä¢ All data is removed from table
    ...    ‚Ä¢ Table structure remains intact
    [Arguments]    ${table_name}

    Log    üóëÔ∏è Truncating table: ${table_name}

    ${sql}=    Set Variable    TRUNCATE TABLE ${table_name}
    Execute SQL String Safe    ${sql}

    Log    ‚úÖ Table '${table_name}' truncated successfully

Get Table Columns
    [Documentation]    Gets column names from database table
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ Table exists in the database
    ...    ‚Ä¢ Column metadata query executes successfully
    ...    ‚Ä¢ Returns list of column names
    ...    ‚Ä¢ Column information is accurate and current
    [Arguments]    ${table_name}    ${schema}=public    ${exclude_id}=${TRUE}

    Log    üîç Getting columns for table: ${table_name}

    ${id_filter}=    Set Variable If    ${exclude_id}    AND column_name != 'id'    ${EMPTY}

    ${query}=    Set Variable
    ...    SELECT column_name FROM information_schema.columns WHERE table_schema='${schema}' AND table_name='${table_name}' ${id_filter} ORDER BY ordinal_position

    ${result}=    Query    ${query}

    ${columns}=    Create List
    FOR    ${row}    IN    @{result}
        ${column}=    Get From List    ${row}    0
        Append To List    ${columns}    ${column}
    END

    Log    üìä Table '${table_name}' columns: ${columns}
    RETURN    ${columns}

Get Table Schema Info
    [Documentation]    Gets detailed schema information for a table
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ Table exists in the database
    ...    ‚Ä¢ Schema query executes successfully
    ...    ‚Ä¢ Returns comprehensive table metadata
    ...    ‚Ä¢ Column details are accurate and complete
    [Arguments]    ${table_name}    ${schema}=public

    Log    üîç Getting schema info for table: ${table_name}

    ${query}=    Set Variable
    ...    SELECT column_name, data_type, is_nullable, column_default, character_maximum_length
    ...    FROM information_schema.columns
    ...    WHERE table_schema='${schema}' AND table_name='${table_name}'
    ...    ORDER BY ordinal_position

    ${results}=    Execute SQL Query And Get Results    ${query}

    Log    üìä Schema info for '${table_name}': ${results.__len__()} columns
    RETURN    ${results}

################## DATA VALIDATION AND COUNTING ##################

Validate Table Data Count
    [Documentation]    Validates that table contains expected number of rows
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ Table exists and is accessible
    ...    ‚Ä¢ Actual row count matches expected count exactly
    ...    ‚Ä¢ COUNT query executes successfully
    [Arguments]    ${table_name}    ${expected_count}

    Log    üîç Validating data count for table: ${table_name}
    Log    üìä Expected count: ${expected_count}

    ${actual_count}=    Get Table Row Count    ${table_name}

    Should Be Equal As Numbers    ${actual_count}    ${expected_count}
    ...    Table '${table_name}' has ${actual_count} rows, expected ${expected_count}

    Log    ‚úÖ Table data count validation passed: ${actual_count} rows

Compare Table Row Counts
    [Documentation]    Compares row counts between two tables
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ Both tables exist and are accessible
    ...    ‚Ä¢ Row count queries execute successfully
    ...    ‚Ä¢ Comparison logic works correctly
    [Arguments]    ${table1}    ${table2}    ${should_match}=${TRUE}

    Log    üîç Comparing row counts between tables...
    Log    üìä Table 1: ${table1}
    Log    üìä Table 2: ${table2}

    ${count1}=    Get Table Row Count    ${table1}
    ${count2}=    Get Table Row Count    ${table2}

    Log    üìä ${table1}: ${count1} rows
    Log    üìä ${table2}: ${count2} rows

    IF    ${should_match}
        Should Be Equal As Numbers    ${count1}    ${count2}
        ...    Table row counts don't match: ${table1}(${count1}) != ${table2}(${count2})
        Log    ‚úÖ Table row counts match: ${count1} rows each
    ELSE
        Should Not Be Equal As Numbers    ${count1}    ${count2}
        ...    Table row counts should not match but both have ${count1} rows
        Log    ‚úÖ Table row counts differ as expected: ${count1} vs ${count2}
    END

Validate Table Has Data
    [Documentation]    Validates that table contains at least one row
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ Table exists and is accessible
    ...    ‚Ä¢ Table contains at least one row of data
    ...    ‚Ä¢ COUNT query executes successfully
    [Arguments]    ${table_name}

    Log    üîç Validating table has data: ${table_name}

    ${count}=    Get Table Row Count    ${table_name}

    Should Be True    ${count} > 0
    ...    Table '${table_name}' is empty (0 rows)

    Log    ‚úÖ Table '${table_name}' contains data: ${count} rows

Validate Table Is Empty
    [Documentation]    Validates that table is empty (0 rows)
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ Table exists and is accessible
    ...    ‚Ä¢ Table contains exactly 0 rows
    ...    ‚Ä¢ COUNT query executes successfully
    [Arguments]    ${table_name}

    Log    üîç Validating table is empty: ${table_name}

    ${count}=    Get Table Row Count    ${table_name}

    Should Be Equal As Numbers    ${count}    0
    ...    Table '${table_name}' is not empty (${count} rows)

    Log    ‚úÖ Table '${table_name}' is empty as expected

################## TRANSACTION MANAGEMENT ##################

Begin Transaction
    [Documentation]    Begins a database transaction
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ Database connection supports transactions
    ...    ‚Ä¢ Transaction begins successfully
    ...    ‚Ä¢ Transaction state is properly managed

    Log    üîÑ Beginning database transaction...
    Execute SQL String    BEGIN
    Log    ‚úÖ Transaction started successfully

Commit Transaction
    [Documentation]    Commits current database transaction
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ Active transaction exists
    ...    ‚Ä¢ Transaction commits successfully
    ...    ‚Ä¢ All changes are persisted to database

    Log    üíæ Committing database transaction...
    Execute SQL String    COMMIT
    Log    ‚úÖ Transaction committed successfully

Rollback Transaction
    [Documentation]    Rolls back current database transaction
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ Active transaction exists
    ...    ‚Ä¢ Transaction rollback completes successfully
    ...    ‚Ä¢ All changes are discarded

    Log    ‚Ü©Ô∏è Rolling back database transaction...
    Execute SQL String    ROLLBACK
    Log    ‚úÖ Transaction rolled back successfully

Execute SQL With Transaction
    [Documentation]    Executes SQL statements within a transaction with automatic rollback on error
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ Transaction management works correctly
    ...    ‚Ä¢ SQL statements execute successfully or transaction is rolled back
    ...    ‚Ä¢ Database state is consistent after operation
    [Arguments]    ${sql_statements}    ${auto_commit}=${TRUE}

    Log    üîÑ Executing SQL with transaction management...

    TRY
        Begin Transaction

        # Handle both single statement and list of statements
        ${is_list}=    Evaluate    isinstance($sql_statements, list)

        IF    ${is_list}
            FOR    ${statement}    IN    @{sql_statements}
                Execute SQL String Safe    ${statement}
            END
        ELSE
            Execute SQL String Safe    ${sql_statements}
        END

        IF    ${auto_commit}
            Commit Transaction
            Log    ‚úÖ SQL executed and committed successfully
        ELSE
            Log    ‚úÖ SQL executed successfully (transaction not committed)
        END
    EXCEPT    AS    ${error}
        Log    ‚ùå SQL execution failed, rolling back transaction: ${error}
        Rollback Transaction
        Fail    SQL execution failed: ${error}
    END

################## DATABASE UTILITY KEYWORDS ##################

Wait For Database Connection
    [Documentation]    Waits for database to become available with retry logic
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ Database eventually becomes available within timeout
    ...    ‚Ä¢ Connection test succeeds at least once
    ...    ‚Ä¢ Retry logic works correctly
    [Arguments]    ${timeout}=30s    ${retry_interval}=2s

    Log    ‚è≥ Waiting for database connection (timeout: ${timeout})...

    ${end_time}=    Add Time To Date    ${NOW}    ${timeout}

    WHILE    True
        ${current_time}=    Get Current Date
        ${time_exceeded}=    Evaluate    '${current_time}' > '${end_time}'

        IF    ${time_exceeded}
            Fail    Database connection timeout after ${timeout}
        END

        ${connected}=    Test Database Connection
        IF    ${connected}
            Log    ‚úÖ Database connection established
            BREAK
        END

        Log    ‚è≥ Database not ready, retrying in ${retry_interval}...
        Sleep    ${retry_interval}
    END

Execute SQL Template
    [Documentation]    Executes SQL with variable substitution from template
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ Template variables are properly substituted
    ...    ‚Ä¢ Resulting SQL is valid and executes successfully
    ...    ‚Ä¢ Variable substitution works correctly
    [Arguments]    ${sql_template}    &{variables}

    Log    üìù Executing SQL template with variables...
    Log    üîß Variables: ${variables}

    # Substitute variables in SQL template
    ${sql_with_vars}=    Set Variable    ${sql_template}
    FOR    ${var_name}    ${var_value}    IN    &{variables}
        ${sql_with_vars}=    Replace String    ${sql_with_vars}    {${var_name}}    ${var_value}
    END

    Log    üìù Final SQL: ${sql_with_vars}
    Execute SQL String Safe    ${sql_with_vars}
    Log    ‚úÖ SQL template executed successfully

Backup Table Data
    [Documentation]    Creates a backup of table data (simplified version)
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ Source table exists and is accessible
    ...    ‚Ä¢ Backup table is created successfully
    ...    ‚Ä¢ All data is copied correctly
    [Arguments]    ${source_table}    ${backup_table}    ${drop_if_exists}=${TRUE}

    Log    üíæ Creating backup of table: ${source_table} ‚Üí ${backup_table}

    IF    ${drop_if_exists}    Drop Table If Exists    ${backup_table}

    ${sql}=    Set Variable    CREATE TABLE ${backup_table} AS SELECT * FROM ${source_table}
    Execute SQL String Safe    ${sql}

    # Verify backup
    ${source_count}=    Get Table Row Count    ${source_table}
    ${backup_count}=    Get Table Row Count    ${backup_table}

    Should Be Equal As Numbers    ${source_count}    ${backup_count}
    ...    Backup failed: source has ${source_count} rows, backup has ${backup_count}

    Log    ‚úÖ Table backup completed: ${backup_count} rows copied

Clean Database Tables
    [Documentation]    Cleans up test tables by truncating or dropping them
    ...    üìã ASSERTIONS:
    ...    ‚Ä¢ Cleanup operations complete successfully
    ...    ‚Ä¢ Tables are properly removed or emptied
    ...    ‚Ä¢ No errors during cleanup process
    [Arguments]    ${tables}    ${operation}=TRUNCATE

    Log    üßπ Cleaning database tables (${operation})...
    Log    üìã Tables: ${tables}

    # Handle both single table and list of tables
    ${is_list}=    Evaluate    isinstance($tables, list)
    ${table_list}=    Set Variable If    ${is_list}    ${tables}    [${tables}]

    FOR    ${table}    IN    @{table_list}
        TRY
            IF    '${operation}' == 'TRUNCATE'
                Truncate Table    ${table}
            ELSE IF    '${operation}' == 'DROP'
                Drop Table If Exists    ${table}
            ELSE
                Log    ‚ö†Ô∏è Unknown operation: ${operation}, skipping table ${table}
            END
        EXCEPT    AS    ${error}
            Log    ‚ö†Ô∏è Failed to clean table ${table}: ${error}
        END
    END

    Log    ‚úÖ Database cleanup completed

Execute SQL On Database
    [Documentation]    Execute SQL on a specific database connection
    ...    database_type should be 'postgres' or 'oracle'
    [Arguments]    ${sql}    ${database_type}

    # Close any existing connection to avoid warnings
    Run Keyword And Ignore Error    Disconnect From Database

    # Execute based on database type
    IF    '${database_type}' == 'postgres'
        # Connect to PostgreSQL
        Connect to Postgres Database
        ...    ${POSTGRES_DBNAME}
        ...    ${POSTGRES_DBUSER}
        ...    ${POSTGRES_DBPASS}
        ...    ${POSTGRES_HOST}
        ...    ${POSTGRES_DBPORT}
        Execute SQL String    ${sql}
    ELSE IF    '${database_type}' == 'oracle'
        # Connect to Oracle
        Connect to Oracle Database
        ...    ${ORACLE_DBNAME}
        ...    ${ORACLE_DBUSER}
        ...    ${ORACLE_DBPASS}
        ...    ${ORACLE_HOST}
        ...    ${ORACLE_DBPORT}
        Execute SQL String    ${sql}
    ELSE IF    '${database_type}' == 'sqlserver'
        # Connect to SQL Server
        Connect to SQL Server Database
        ...    ${SQLSERVER_DBNAME}
        ...    ${SQLSERVER_DBUSER}
        ...    ${SQLSERVER_DBPASS}
        ...    ${SQLSERVER_HOST}
        ...    ${SQLSERVER_DBPORT}
        Execute SQL String    ${sql}
    ELSE
        Fail    Unknown database type: ${database_type}. Use 'postgres', 'oracle', or 'sqlserver'
    END
