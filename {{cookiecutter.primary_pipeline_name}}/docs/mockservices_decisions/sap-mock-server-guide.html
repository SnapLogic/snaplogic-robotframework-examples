<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SAP Mock Server Guide — Understanding SAP for Mocking</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #1b4332 0%, #2d6a4f 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        /* ═══════════════════════════════════════════════════════════════
           Header
           ═══════════════════════════════════════════════════════════════ */
        .header {
            background: white;
            border-radius: 10px;
            padding: 20px 30px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            color: #333;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 22px;
        }

        .header-subtitle {
            color: #666;
            font-size: 13px;
        }

        /* ═══════════════════════════════════════════════════════════════
           Navigation
           ═══════════════════════════════════════════════════════════════ */
        .nav-section {
            background: white;
            border-radius: 10px;
            padding: 15px 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .nav-section h3 {
            color: #333;
            font-size: 13px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tab-nav {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .tab-btn {
            padding: 8px 16px;
            border: 2px solid #2d6a4f;
            background: white;
            color: #2d6a4f;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s;
            text-decoration: none;
        }

        .tab-btn:hover, .tab-btn.active {
            background: #2d6a4f;
            color: white;
        }

        .tab-btn.blue-tab {
            border-color: #2980b9;
            color: #2980b9;
        }
        .tab-btn.blue-tab:hover, .tab-btn.blue-tab.active {
            background: #2980b9;
            color: white;
        }

        .tab-btn.purple-tab {
            border-color: #8e44ad;
            color: #8e44ad;
        }
        .tab-btn.purple-tab:hover, .tab-btn.purple-tab.active {
            background: #8e44ad;
            color: white;
        }

        .tab-btn.orange-tab {
            border-color: #e67e22;
            color: #e67e22;
        }
        .tab-btn.orange-tab:hover, .tab-btn.orange-tab.active {
            background: #e67e22;
            color: white;
        }

        .tab-btn.red-tab {
            border-color: #e74c3c;
            color: #e74c3c;
        }
        .tab-btn.red-tab:hover, .tab-btn.red-tab.active {
            background: #e74c3c;
            color: white;
        }

        .tab-btn.gray-tab {
            border-color: #7f8c8d;
            color: #7f8c8d;
        }
        .tab-btn.gray-tab:hover, .tab-btn.gray-tab.active {
            background: #7f8c8d;
            color: white;
        }

        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }

        /* ═══════════════════════════════════════════════════════════════
           Data Sections / Cards
           ═══════════════════════════════════════════════════════════════ */
        .data-section {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .data-section h2 {
            color: #333;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 18px;
        }

        .data-section h2 .badge {
            background: #2d6a4f;
            color: white;
            font-size: 12px;
            padding: 3px 10px;
            border-radius: 12px;
            font-weight: normal;
        }
        .data-section h2 .badge.blue { background: #2980b9; }
        .data-section h2 .badge.purple { background: #8e44ad; }
        .data-section h2 .badge.orange { background: #e67e22; }
        .data-section h2 .badge.red { background: #e74c3c; }

        .data-section h3 {
            color: #444;
            margin: 20px 0 10px 0;
            font-size: 15px;
        }

        .data-section p {
            color: #555;
            font-size: 14px;
            line-height: 1.7;
            margin-bottom: 12px;
        }

        /* ═══════════════════════════════════════════════════════════════
           Info Boxes
           ═══════════════════════════════════════════════════════════════ */
        .info-box {
            background: #e8f5e9;
            border-left: 4px solid #2d6a4f;
            padding: 12px 16px;
            margin-bottom: 15px;
            border-radius: 0 5px 5px 0;
            font-size: 13px;
            color: #1b4332;
            line-height: 1.6;
        }
        .info-box code {
            background: #d8f3dc;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .info-box.blue {
            background: #e8f0fe;
            border-left-color: #2980b9;
            color: #1a3a5c;
        }
        .info-box.blue code { background: #d0e3f7; }

        .info-box.purple {
            background: #f3e8fa;
            border-left-color: #8e44ad;
            color: #4a1a6b;
        }
        .info-box.purple code { background: #e8d5f5; }

        .info-box.orange {
            background: #fef3e2;
            border-left-color: #e67e22;
            color: #6b3a0a;
        }
        .info-box.orange code { background: #fde6c8; }

        .info-box.red {
            background: #fde8e8;
            border-left-color: #e74c3c;
            color: #6b1a1a;
        }
        .info-box.red code { background: #f9d0d0; }

        /* ═══════════════════════════════════════════════════════════════
           Tables
           ═══════════════════════════════════════════════════════════════ */
        .table-container { overflow-x: auto; }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th {
            background: #f7f7f7;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #333;
            border-bottom: 2px solid #e0e0e0;
            font-size: 13px;
        }

        td {
            padding: 12px;
            border-bottom: 1px solid #f0f0f0;
            font-size: 13px;
            vertical-align: top;
        }

        tr:hover { background: #f9f9f9; }

        td code, th code {
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #333;
        }

        /* ═══════════════════════════════════════════════════════════════
           Code Blocks
           ═══════════════════════════════════════════════════════════════ */
        .code-block {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 600px;
            overflow-y: auto;
            white-space: pre;
            margin-bottom: 15px;
            line-height: 1.5;
        }

        .code-block .comment { color: #6a9955; }
        .code-block .keyword { color: #569cd6; }
        .code-block .string { color: #ce9178; }
        .code-block .function { color: #dcdcaa; }
        .code-block .variable { color: #9cdcfe; }
        .code-block .highlight { background: #264f2a; display: inline; }
        .code-block .highlight-blue { background: #1e3a5f; display: inline; }
        .code-block .highlight-red { background: #5f1e1e; display: inline; }
        .code-block .dim { color: #666; }
        .code-block .arrow { color: #27ae60; font-weight: bold; }
        .code-block .match { color: #27ae60; font-weight: bold; }
        .code-block .nomatch { color: #e74c3c; }
        .code-block .url-fixed { color: #808080; }
        .code-block .url-dynamic { color: #4ec9b0; font-weight: bold; }
        .code-block .url-host { color: #569cd6; }
        .code-block .label { color: #dcdcaa; }
        .code-block .warn { color: #e67e22; font-weight: bold; }
        .code-block .danger { color: #e74c3c; font-weight: bold; }
        .code-block .success { color: #27ae60; font-weight: bold; }

        .code-label {
            background: #2d6a4f;
            color: white;
            display: inline-block;
            padding: 3px 10px;
            border-radius: 5px 5px 0 0;
            font-size: 12px;
            font-weight: 600;
        }
        .code-label.blue { background: #2980b9; }
        .code-label.purple { background: #8e44ad; }
        .code-label.orange { background: #e67e22; }
        .code-label.red { background: #e74c3c; }

        /* ═══════════════════════════════════════════════════════════════
           Stats Cards
           ═══════════════════════════════════════════════════════════════ */
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            text-align: center;
        }

        .stat-card h3 {
            color: #666;
            font-size: 11px;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .stat-card .label-text {
            font-size: 14px;
            font-weight: bold;
            color: #2d6a4f;
        }

        .stat-card.blue .label-text { color: #2980b9; }
        .stat-card.purple .label-text { color: #8e44ad; }
        .stat-card.orange .label-text { color: #e67e22; }
        .stat-card.red .label-text { color: #e74c3c; }
        .stat-card.gray .label-text { color: #7f8c8d; }

        /* ═══════════════════════════════════════════════════════════════
           Comparison Columns
           ═══════════════════════════════════════════════════════════════ */
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 15px 0;
        }

        .comparison-col {
            background: #fafafa;
            border-radius: 8px;
            padding: 15px;
            border: 2px solid #e0e0e0;
        }

        .comparison-col h4 {
            margin-bottom: 10px;
            font-size: 14px;
            color: #333;
        }

        .comparison-col.real {
            border-color: #2980b9;
            background: #e8f0fe;
        }
        .comparison-col.real h4 { color: #2980b9; }

        .comparison-col.mock {
            border-color: #2d6a4f;
            background: #e8f5e9;
        }
        .comparison-col.mock h4 { color: #2d6a4f; }

        .comparison-col.danger {
            border-color: #e74c3c;
            background: #fde8e8;
        }
        .comparison-col.danger h4 { color: #e74c3c; }

        .comparison-col.success {
            border-color: #27ae60;
            background: #e8f5e9;
        }
        .comparison-col.success h4 { color: #27ae60; }

        /* ═══════════════════════════════════════════════════════════════
           Method Badges
           ═══════════════════════════════════════════════════════════════ */
        .method {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            color: white;
            font-family: 'Courier New', monospace;
            letter-spacing: 0.5px;
        }
        .method.get { background: #27ae60; }
        .method.post { background: #2980b9; }
        .method.patch { background: #e67e22; }
        .method.delete { background: #e74c3c; }
        .method.put { background: #8e44ad; }
        .method.rfc { background: #7f8c8d; }

        /* ═══════════════════════════════════════════════════════════════
           Flow Steps
           ═══════════════════════════════════════════════════════════════ */
        .flow-step {
            display: flex;
            align-items: flex-start;
            margin-bottom: 15px;
        }

        .flow-number {
            background: #2d6a4f;
            color: white;
            min-width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            margin-right: 15px;
            flex-shrink: 0;
        }
        .flow-number.blue { background: #2980b9; }
        .flow-number.purple { background: #8e44ad; }
        .flow-number.orange { background: #e67e22; }
        .flow-number.red { background: #e74c3c; }

        .flow-content { flex: 1; }

        .flow-content h4 {
            color: #333;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .flow-content p {
            color: #666;
            font-size: 13px;
            line-height: 1.5;
        }

        /* ═══════════════════════════════════════════════════════════════
           Status Badges
           ═══════════════════════════════════════════════════════════════ */
        .status-badge {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            color: white;
        }
        .status-badge.yes { background: #27ae60; }
        .status-badge.no { background: #e74c3c; }
        .status-badge.partial { background: #e67e22; }

        @media (max-width: 768px) {
            .comparison { grid-template-columns: 1fr; }
            .stats { grid-template-columns: repeat(2, 1fr); }
            .header { flex-direction: column; gap: 10px; text-align: center; }
        }
    </style>
</head>
<body>
    <div class="container">

        <!-- ═══════════════════════════════════════════════════════════════
             HEADER
             ═══════════════════════════════════════════════════════════════ -->
        <div class="header">
            <div>
                <h1>SAP Mock Server Guide</h1>
                <div class="header-subtitle">Understanding SAP Systems, BAPI, IDoc, RFC vs OData &mdash; and What We Can Mock</div>
            </div>
            <div class="header-subtitle">SLIM Mock Service Documentation</div>
        </div>

        <!-- ═══════════════════════════════════════════════════════════════
             QUICK STATS
             ═══════════════════════════════════════════════════════════════ -->
        <div class="stats">
            <div class="stat-card">
                <h3>SAP Protocol #1</h3>
                <div class="label-text">RFC (Proprietary Binary)</div>
            </div>
            <div class="stat-card blue">
                <h3>SAP Protocol #2</h3>
                <div class="label-text">OData (HTTP/REST)</div>
            </div>
            <div class="stat-card red">
                <h3>RFC Mockable?</h3>
                <div class="label-text">NO (Not HTTP)</div>
            </div>
            <div class="stat-card">
                <h3>OData Mockable?</h3>
                <div class="label-text">YES (Django)</div>
            </div>
            <div class="stat-card orange">
                <h3>Key Concept</h3>
                <div class="label-text">BAPI = SAP's API</div>
            </div>
        </div>

        <!-- ═══════════════════════════════════════════════════════════════
             TAB NAVIGATION
             ═══════════════════════════════════════════════════════════════ -->
        <div class="nav-section">
            <h3>Documentation Sections</h3>
            <div class="tab-nav">
                <button class="tab-btn active" data-tab="what-is-sap" onclick="showTab('what-is-sap')">What is SAP?</button>
                <button class="tab-btn blue-tab" data-tab="what-is-bapi" onclick="showTab('what-is-bapi')">What is a BAPI?</button>
                <button class="tab-btn purple-tab" data-tab="what-is-idoc" onclick="showTab('what-is-idoc')">What is an IDoc?</button>
                <button class="tab-btn orange-tab" data-tab="what-is-rfc" onclick="showTab('what-is-rfc')">What is RFC?</button>
                <button class="tab-btn orange-tab" data-tab="rfc-vs-odata" onclick="showTab('rfc-vs-odata')">RFC vs OData</button>
                <button class="tab-btn red-tab" data-tab="can-we-mock" onclick="showTab('can-we-mock')">Can We Mock SAP with Django?</button>
                <button class="tab-btn" data-tab="rfc-mock-options" onclick="showTab('rfc-mock-options')">RFC Mocking Options</button>
                <button class="tab-btn" data-tab="snaplogic-snaps" onclick="showTab('snaplogic-snaps')">SnapLogic SAP Snaps</button>
                <button class="tab-btn blue-tab" data-tab="odata-urls" onclick="showTab('odata-urls')">OData URL Patterns</button>
                <button class="tab-btn gray-tab" data-tab="mock-strategy" onclick="showTab('mock-strategy')">Mock Strategy</button>
                <button class="tab-btn blue-tab" data-tab="jco-pyrfc" onclick="showTab('jco-pyrfc')">PyRFC vs JCo</button>
                <button class="tab-btn purple-tab" data-tab="impl-plan" onclick="showTab('impl-plan')">Implementation Plan</button>
            </div>
        </div>

        <!-- ═══════════════════════════════════════════════════════════════
             TAB 1: WHAT IS SAP?
             ═══════════════════════════════════════════════════════════════ -->
        <div id="what-is-sap" class="tab-content active">
            <div class="data-section">
                <h2>What is SAP? <span class="badge">Basics</span></h2>

                <p>SAP (Systems, Applications, and Products) is an enterprise software system that manages core business operations &mdash; finance, supply chain, manufacturing, HR, sales, etc. Think of it as the "operating system" for large enterprises like Caterpillar.</p>

                <div class="info-box blue">
                    <strong>Simple analogy:</strong> If Salesforce manages your <strong>customers and sales</strong>, SAP manages <strong>everything else</strong> &mdash; manufacturing, supply chain, inventory, finance, HR, procurement, and more.
                </div>

                <h3>SAP's Communication Methods (Oldest to Newest)</h3>
                <div class="code-block">
<span class="comment">SAP Communication Evolution:</span>

<span class="dim">1990s</span>   <span class="warn">RFC / BAPI</span>           Proprietary binary protocol (port 33xx)
         <span class="dim">|-- SAP JCo</span>            Java library to call BAPIs
         <span class="dim">|-- SAP NCo</span>            .NET library to call BAPIs
         <span class="dim">|-- PyRFC</span>              Python library to call BAPIs
         <span class="dim">|</span>
         <span class="dim">|</span>   <span class="danger">Your SAP IDoc Read snap uses THIS</span>
         <span class="dim">|</span>

<span class="dim">2000s</span>   <span class="variable">SOAP / Web Services</span>  HTTP + XML (verbose, complex)
         <span class="dim">|-- SAP PI/PO</span>          Middleware for SOAP routing
         <span class="dim">|-- Enterprise SOA</span>     SAP's service-oriented architecture
         <span class="dim">|</span>

<span class="dim">2010s</span>   <span class="success">OData / REST</span>         HTTP + JSON (modern, simple)
         <span class="dim">|-- SAP Gateway</span>        Exposes OData services
         <span class="dim">|-- SAP S/4HANA APIs</span>   Modern REST APIs
         <span class="dim">|-- SAP BTP</span>            Cloud platform APIs
         <span class="dim">|</span>
         <span class="dim">|</span>   <span class="success">SAP S/4HANA snaps use THIS (mockable with Django!)</span></div>

                <h3>SAP System Architecture</h3>
                <div class="code-block">
<span class="comment">A typical SAP system:</span>

<span class="dim">+----------------------------------------------------------------+</span>
<span class="dim">|</span>                      <span class="label">SAP Application Server</span>                    <span class="dim">|</span>
<span class="dim">|</span>                                                                <span class="dim">|</span>
<span class="dim">|</span>   <span class="string">ABAP Runtime</span>         Business logic written in ABAP language  <span class="dim">|</span>
<span class="dim">|</span>   <span class="string">Function Modules</span>     BAPIs, RFC-enabled functions              <span class="dim">|</span>
<span class="dim">|</span>   <span class="string">IDoc Framework</span>       Intermediate Documents for data exchange  <span class="dim">|</span>
<span class="dim">|</span>   <span class="string">SAP Gateway</span>          OData REST API layer (modern)             <span class="dim">|</span>
<span class="dim">|</span>                                                                <span class="dim">|</span>
<span class="dim">|</span>   <span class="variable">Port 3300-3399</span>       RFC / BAPI calls (proprietary binary)    <span class="dim">|</span>
<span class="dim">|</span>   <span class="variable">Port 8000-8099</span>       HTTP / OData calls (standard REST)       <span class="dim">|</span>
<span class="dim">|</span>   <span class="variable">Port 3200-3299</span>       SAP GUI connections                      <span class="dim">|</span>
<span class="dim">|</span>                                                                <span class="dim">|</span>
<span class="dim">+----------------------------------------------------------------+</span>
<span class="dim">|</span>                   <span class="label">SAP HANA Database</span>                          <span class="dim">|</span>
<span class="dim">|</span>          (stores all business data, tables, IDocs)             <span class="dim">|</span>
<span class="dim">+----------------------------------------------------------------+</span></div>

                <h3>Key SAP Account Settings (From Your Screenshot)</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>Field</th><th>Example Value</th><th>What It Means</th><th>Mock Implication</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Application server*</strong></td>
                                <td><code>sap-server.company.com</code></td>
                                <td>Hostname of the SAP server</td>
                                <td><strong>THIS is what we replace with mock hostname</strong></td>
                            </tr>
                            <tr>
                                <td><strong>System number*</strong></td>
                                <td><code>00</code></td>
                                <td>SAP instance number (determines port: 33<strong>00</strong>)</td>
                                <td>Mock can ignore (just for port calculation)</td>
                            </tr>
                            <tr>
                                <td><strong>Client*</strong></td>
                                <td><code>100</code> or <code>800</code></td>
                                <td>SAP mandant/tenant within the server</td>
                                <td>Mock can accept any value</td>
                            </tr>
                            <tr>
                                <td><strong>Language*</strong></td>
                                <td><code>EN</code></td>
                                <td>Language for SAP responses</td>
                                <td>Mock can ignore</td>
                            </tr>
                            <tr>
                                <td><strong>Username</strong></td>
                                <td><code>RFC_USER</code></td>
                                <td>SAP system user for RFC calls</td>
                                <td>Mock accepts anything</td>
                            </tr>
                            <tr>
                                <td><strong>Password</strong></td>
                                <td>(hidden)</td>
                                <td>SAP password</td>
                                <td>Mock accepts anything</td>
                            </tr>
                            <tr>
                                <td><strong>Peak limit*</strong></td>
                                <td><code>5</code></td>
                                <td>Max concurrent RFC connections</td>
                                <td>Mock can ignore</td>
                            </tr>
                            <tr>
                                <td><strong>Connection pool capacity*</strong></td>
                                <td><code>1</code></td>
                                <td>Connection pooling size</td>
                                <td>Mock can ignore</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- ═══════════════════════════════════════════════════════════════
             TAB 2: WHAT IS A BAPI?
             ═══════════════════════════════════════════════════════════════ -->
        <div id="what-is-bapi" class="tab-content">
            <div class="data-section">
                <h2>What is a BAPI? <span class="badge blue">Core Concept</span></h2>

                <p><strong>BAPI</strong> stands for <strong>Business Application Programming Interface</strong>. Think of it as SAP's version of a REST API endpoint &mdash; but older and using SAP's proprietary RFC protocol instead of HTTP.</p>

                <div class="info-box blue">
                    <strong>Simple definition:</strong> A BAPI is a <strong>pre-built function inside SAP</strong> that performs a specific business operation. SAP provides <strong>thousands</strong> of them out of the box.
                </div>

                <h3>BAPI vs REST API Analogy</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>Concept</th><th>Web / REST World</th><th>SAP World</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Create a customer</strong></td>
                                <td><code>POST /api/customers</code></td>
                                <td><code>BAPI_CUSTOMER_CREATEFROMDATA1</code></td>
                            </tr>
                            <tr>
                                <td><strong>Get a sales order</strong></td>
                                <td><code>GET /api/orders/12345</code></td>
                                <td><code>BAPI_SALESORDER_GETLIST</code></td>
                            </tr>
                            <tr>
                                <td><strong>Update an order</strong></td>
                                <td><code>PUT /api/orders/12345</code></td>
                                <td><code>BAPI_SALESORDER_CHANGE</code></td>
                            </tr>
                            <tr>
                                <td><strong>Read an IDoc</strong></td>
                                <td><code>GET /api/idocs/12345</code></td>
                                <td><code>IDOC_READ_COMPLETELY</code></td>
                            </tr>
                            <tr>
                                <td><strong>Protocol</strong></td>
                                <td>HTTP / HTTPS</td>
                                <td>RFC (proprietary binary)</td>
                            </tr>
                            <tr>
                                <td><strong>Data format</strong></td>
                                <td>JSON</td>
                                <td>SAP structures (binary)</td>
                            </tr>
                            <tr>
                                <td><strong>Function library</strong></td>
                                <td>REST API collection</td>
                                <td>SAP Business Object Repository</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Common SAP BAPIs</h3>
                <div class="code-block">
<span class="comment">SAP provides thousands of BAPIs. Here are some common ones:</span>

<span class="label">Customer Management:</span>
  BAPI_CUSTOMER_CREATEFROMDATA1     <span class="arrow">&rarr;</span> Create a customer
  BAPI_CUSTOMER_GETDETAIL2         <span class="arrow">&rarr;</span> Read customer details

<span class="label">Sales Orders:</span>
  BAPI_SALESORDER_CREATEFROMDAT2   <span class="arrow">&rarr;</span> Create a sales order
  BAPI_SALESORDER_GETLIST          <span class="arrow">&rarr;</span> List sales orders
  BAPI_SALESORDER_CHANGE           <span class="arrow">&rarr;</span> Update a sales order

<span class="label">Materials:</span>
  BAPI_MATERIAL_GETLIST            <span class="arrow">&rarr;</span> List materials

<span class="label">IDoc Operations:</span>
  IDOC_READ_COMPLETELY             <span class="arrow">&rarr;</span> Read an IDoc (standard, NOT remote-enabled)
  <span class="highlight">Z_SNAP_IDOC_READ_COMPLETELY</span>      <span class="arrow">&rarr;</span> Custom wrapper (remote-enabled, used by SnapLogic)

<span class="label">Transaction Control:</span>
  BAPI_TRANSACTION_COMMIT          <span class="arrow">&rarr;</span> Commit a transaction
  BAPI_TRANSACTION_ROLLBACK        <span class="arrow">&rarr;</span> Rollback a transaction</div>

                <h3>How a BAPI Call Works</h3>
                <div class="code-block">
<span class="url-host">External System (SnapLogic)</span>                      <span class="url-host">SAP System</span>

  <span class="string">"Give me sales orders</span>        <span class="label">1. Call BAPI</span>
  <span class="string"> for customer 1001"</span>    <span class="arrow">══════════════════════►</span>   BAPI_SALESORDER_GETLIST
                               Function name +
                               input parameters              Runs ABAP code
                                                              Queries SAP DB
                               <span class="label">2. Return results</span>
   Receives list of        <span class="arrow">◄══════════════════════</span>   Returns data
   orders                      Output parameters +
                               tables</div>

                <h3>BAPI Input/Output Structure</h3>
                <p>Every BAPI has a well-defined interface, like a function signature:</p>

                <div class="code-label blue">Example: BAPI_SALESORDER_GETLIST</div>
                <div class="code-block">
<span class="label">IMPORT parameters</span> (what you send IN):
  <span class="variable">CUSTOMER_NUMBER</span>     = <span class="string">"0000001001"</span>       <span class="comment">(which customer)</span>
  <span class="variable">SALES_ORGANIZATION</span>  = <span class="string">"1000"</span>              <span class="comment">(which org)</span>
  <span class="variable">DOCUMENT_DATE_LOW</span>   = <span class="string">"20240101"</span>          <span class="comment">(date range start)</span>

<span class="label">EXPORT parameters</span> (single values returned):
  <span class="variable">RETURN</span>              = { TYPE: <span class="string">"S"</span>, MESSAGE: <span class="string">"Success"</span> }

<span class="label">TABLE parameters</span> (lists of records returned):
  <span class="variable">SALES_ORDERS</span> = [
    { DOC_NUMBER: <span class="string">"0000012345"</span>, DOC_DATE: <span class="string">"20240115"</span>, NET_VALUE: <span class="string">50000.00</span> },
    { DOC_NUMBER: <span class="string">"0000012346"</span>, DOC_DATE: <span class="string">"20240220"</span>, NET_VALUE: <span class="string">75000.00</span> },
    { DOC_NUMBER: <span class="string">"0000012347"</span>, DOC_DATE: <span class="string">"20240301"</span>, NET_VALUE: <span class="string">12000.00</span> }
  ]</div>

                <h3>Your Snap: Z_SNAP_IDOC_READ_COMPLETELY</h3>
                <p>The <code>Z_</code> prefix means this is a <strong>custom BAPI</strong> &mdash; not provided by SAP out of the box:</p>

                <div class="code-block">
<span class="label">Standard SAP function:</span>     IDOC_READ_COMPLETELY          <span class="danger">NOT remotely callable</span>
                                       <span class="dim">|</span>
                                       <span class="dim">|</span>  SAP admin wraps it in:
                                       <span class="dim">v</span>
<span class="label">Custom BAPI:</span>              <span class="highlight">Z_SNAP_IDOC_READ_COMPLETELY</span>   <span class="success">Remotely callable via RFC</span>
                                       <span class="dim">|</span>
                                       <span class="dim">|</span>  SnapLogic calls this over RFC
                                       <span class="dim">v</span>
                              Returns IDoc data back to SnapLogic</div>

                <div class="info-box orange">
                    <strong>Why the custom wrapper?</strong> SAP's standard <code>IDOC_READ_COMPLETELY</code> is marked as "not remote-enabled" &mdash; meaning it can only be called from inside SAP. Someone had to create a custom copy (<code>Z_SNAP_IDOC_READ_COMPLETELY</code>) flagged as remote-callable so SnapLogic can call it from outside.
                </div>
            </div>
        </div>

        <!-- ═══════════════════════════════════════════════════════════════
             TAB 3: WHAT IS AN IDOC?
             ═══════════════════════════════════════════════════════════════ -->
        <div id="what-is-idoc" class="tab-content">
            <div class="data-section">
                <h2>What is an IDoc? <span class="badge purple">Data Format</span></h2>

                <p><strong>IDoc</strong> stands for <strong>Intermediate Document</strong>. It is SAP's standard data container format for exchanging business data. Think of it as a <strong>standardized envelope</strong> for sending structured business messages &mdash; purchase orders, invoices, shipping notifications, employee records.</p>

                <div class="info-box purple">
                    <strong>Key insight:</strong> An IDoc is NOT a communication protocol. It is a <strong>data format</strong> (like JSON or XML). It needs a transport mechanism (RFC, file transfer, or HTTP) to move between systems.
                </div>

                <h3>IDoc Analogy</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>Concept</th><th>Email World</th><th>SAP IDoc World</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>The envelope</strong></td>
                                <td>Email headers (From, To, Subject, Date)</td>
                                <td><strong>Control Record</strong> (sender, receiver, type, date)</td>
                            </tr>
                            <tr>
                                <td><strong>The message body</strong></td>
                                <td>Email body text</td>
                                <td><strong>Data Records</strong> (business data in segments)</td>
                            </tr>
                            <tr>
                                <td><strong>Delivery tracking</strong></td>
                                <td>Read receipts, delivery status</td>
                                <td><strong>Status Records</strong> (processing audit trail)</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>IDoc Structure: Three Layers</h3>

                <div class="code-block">
<span class="label">IDoc #0000000012345</span>
<span class="dim">+================================================================+</span>
<span class="dim">|</span>  <span class="warn">CONTROL RECORD</span> (the envelope)                                  <span class="dim">|</span>
<span class="dim">|</span>  DOCNUM  = <span class="string">"0000000012345"</span>       <span class="comment">Unique IDoc number</span>             <span class="dim">|</span>
<span class="dim">|</span>  IDOCTP  = <span class="string">"ORDERS05"</span>            <span class="comment">IDoc type (purchase order)</span>     <span class="dim">|</span>
<span class="dim">|</span>  MESTYP  = <span class="string">"ORDERS"</span>              <span class="comment">Message type</span>                   <span class="dim">|</span>
<span class="dim">|</span>  DIRECT  = <span class="string">"2"</span>                   <span class="comment">Direction: 1=Out, 2=In</span>        <span class="dim">|</span>
<span class="dim">|</span>  STATUS  = <span class="string">"53"</span>                  <span class="comment">Successfully posted</span>           <span class="dim">|</span>
<span class="dim">|</span>  SNDPRN  = <span class="string">"EXTSYSTEM"</span>           <span class="comment">Sender</span>                        <span class="dim">|</span>
<span class="dim">|</span>  RCVPRN  = <span class="string">"SAPCLNT100"</span>         <span class="comment">Receiver</span>                      <span class="dim">|</span>
<span class="dim">|</span>  CREDAT  = <span class="string">"20240115"</span>            <span class="comment">Creation date</span>                 <span class="dim">|</span>
<span class="dim">+================================================================+</span>
<span class="dim">|</span>  <span class="success">DATA RECORDS</span> (the business payload, in segments)               <span class="dim">|</span>
<span class="dim">|</span>                                                                <span class="dim">|</span>
<span class="dim">|</span>  Segment 1: <span class="variable">E1EDK01</span> (Header)          Level 1                  <span class="dim">|</span>
<span class="dim">|</span>    <span class="dim">|</span>  SDATA = <span class="string">"&lt;1000-char fixed-width string with order data&gt;"</span>  <span class="dim">|</span>
<span class="dim">|</span>    <span class="dim">|</span>                                                            <span class="dim">|</span>
<span class="dim">|</span>    <span class="dim">+--</span> Segment 2: <span class="variable">E1EDK14</span> (Org data)   Level 2                  <span class="dim">|</span>
<span class="dim">|</span>    <span class="dim">|</span>  SDATA = <span class="string">"&lt;1000-char string with org data&gt;"</span>                <span class="dim">|</span>
<span class="dim">|</span>    <span class="dim">|</span>                                                            <span class="dim">|</span>
<span class="dim">|</span>    <span class="dim">+--</span> Segment 3: <span class="variable">E1EDP01</span> (Line item)  Level 2                  <span class="dim">|</span>
<span class="dim">|</span>        <span class="dim">|</span>  SDATA = <span class="string">"&lt;1000-char string with item data&gt;"</span>             <span class="dim">|</span>
<span class="dim">|</span>        <span class="dim">|</span>                                                         <span class="dim">|</span>
<span class="dim">|</span>        <span class="dim">+--</span> Segment 4: <span class="variable">E1EDP19</span> (Item detail) Level 3              <span class="dim">|</span>
<span class="dim">|</span>                                                                <span class="dim">|</span>
<span class="dim">+================================================================+</span>
<span class="dim">|</span>  <span class="url-host">STATUS RECORDS</span> (processing audit trail)                       <span class="dim">|</span>
<span class="dim">|</span>                                                                <span class="dim">|</span>
<span class="dim">|</span>  Status 50: <span class="string">"IDoc added"</span>              2024-01-15 14:30:22      <span class="dim">|</span>
<span class="dim">|</span>  Status 62: <span class="string">"IDoc passed to app"</span>      2024-01-15 14:30:23      <span class="dim">|</span>
<span class="dim">|</span>  Status 53: <span class="string">"Application doc posted"</span>   2024-01-15 14:30:25      <span class="dim">|</span>
<span class="dim">+================================================================+</span></div>

                <h3>Common IDoc Types</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>IDoc Type</th><th>Message Type</th><th>Business Purpose</th></tr>
                        </thead>
                        <tbody>
                            <tr><td><code>ORDERS05</code></td><td>ORDERS</td><td>Purchase Orders</td></tr>
                            <tr><td><code>INVOIC02</code></td><td>INVOIC</td><td>Invoices</td></tr>
                            <tr><td><code>DESADV01</code></td><td>DESADV</td><td>Delivery / Shipping Notification</td></tr>
                            <tr><td><code>MATMAS05</code></td><td>MATMAS</td><td>Material Master Data</td></tr>
                            <tr><td><code>DEBMAS07</code></td><td>DEBMAS</td><td>Customer Master Data</td></tr>
                            <tr><td><code>CREMAS04</code></td><td>CREMAS</td><td>Vendor Master Data</td></tr>
                            <tr><td><code>HRMD_A07</code></td><td>HRMD_A</td><td>HR / Employee Data</td></tr>
                        </tbody>
                    </table>
                </div>

                <h3>How Z_SNAP_IDOC_READ_COMPLETELY Works</h3>

                <div class="code-label purple">Input &amp; Output of the BAPI</div>
                <div class="code-block">
<span class="label">INPUT (what SnapLogic sends):</span>
  <span class="variable">DOCUMENT_NUMBER</span> = <span class="string">"0000000012345"</span>

<span class="label">OUTPUT (what SAP returns):</span>
  <span class="variable">IDOC_CONTROL</span> = {
    DOCNUM: <span class="string">"0000000012345"</span>,
    IDOCTP: <span class="string">"ORDERS05"</span>,
    MESTYP: <span class="string">"ORDERS"</span>,
    DIRECT: <span class="string">"2"</span>,
    STATUS: <span class="string">"53"</span>,
    SNDPRN: <span class="string">"EXTSYSTEM"</span>,
    RCVPRN: <span class="string">"SAPCLNT100"</span>,
    CREDAT: <span class="string">"20240115"</span>,
    CRETIM: <span class="string">"143022"</span>
  }

  <span class="variable">NUMBER_OF_DATA_RECORDS</span>   = <span class="string">5</span>
  <span class="variable">NUMBER_OF_STATUS_RECORDS</span> = <span class="string">3</span>

  <span class="variable">INT_EDIDD</span> = [
    { SEGNUM: <span class="string">"1"</span>, SEGNAM: <span class="string">"E1EDK01"</span>, HLEVEL: <span class="string">"1"</span>, SDATA: <span class="string">"&lt;1000 chars&gt;"</span> },
    { SEGNUM: <span class="string">"2"</span>, SEGNAM: <span class="string">"E1EDK14"</span>, HLEVEL: <span class="string">"2"</span>, SDATA: <span class="string">"&lt;1000 chars&gt;"</span> },
    { SEGNUM: <span class="string">"3"</span>, SEGNAM: <span class="string">"E1EDP01"</span>, HLEVEL: <span class="string">"2"</span>, SDATA: <span class="string">"&lt;1000 chars&gt;"</span> },
    { SEGNUM: <span class="string">"4"</span>, SEGNAM: <span class="string">"E1EDP19"</span>, HLEVEL: <span class="string">"3"</span>, SDATA: <span class="string">"&lt;1000 chars&gt;"</span> },
    { SEGNUM: <span class="string">"5"</span>, SEGNAM: <span class="string">"E1EDS01"</span>, HLEVEL: <span class="string">"2"</span>, SDATA: <span class="string">"&lt;1000 chars&gt;"</span> }
  ]

  <span class="variable">INT_EDIDS</span> = [
    { STATUS: <span class="string">"50"</span>, STATTEXT: <span class="string">"IDoc added"</span>,              LOGDAT: <span class="string">"20240115"</span> },
    { STATUS: <span class="string">"62"</span>, STATTEXT: <span class="string">"IDoc passed to app"</span>,     LOGDAT: <span class="string">"20240115"</span> },
    { STATUS: <span class="string">"53"</span>, STATTEXT: <span class="string">"Application doc posted"</span>, LOGDAT: <span class="string">"20240115"</span> }
  ]

<span class="label">EXCEPTIONS:</span>
  <span class="danger">DOCUMENT_NOT_EXIST</span>       <span class="comment">IDoc number not found</span>
  <span class="danger">DOCUMENT_NUMBER_INVALID</span>  <span class="comment">Bad document number format</span></div>
            </div>
        </div>

        <!-- ═══════════════════════════════════════════════════════════════
             TAB 4: WHAT IS RFC?
             ═══════════════════════════════════════════════════════════════ -->
        <div id="what-is-rfc" class="tab-content">
            <div class="data-section">
                <h2>What is RFC? <span class="badge orange">Core Concept</span></h2>

                <p><strong>RFC = Remote Function Call.</strong> It's SAP's version of an API call &mdash; but older and proprietary. Think of it as <strong>SAP's REST API</strong>, built in the 1990s before REST existed.</p>

                <div class="info-box">
                    <strong>One-line definition:</strong> RFC is SAP's proprietary way of calling a function on a remote SAP server &mdash; like a REST API call, but using a binary protocol over TCP instead of HTTP.
                </div>

                <h3>RFC vs REST API &mdash; Side-by-Side</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>Concept</th><th>Web World (what you know)</th><th>SAP World (RFC)</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>How systems talk</strong></td>
                                <td>HTTP (REST API)</td>
                                <td>RFC (Remote Function Call)</td>
                            </tr>
                            <tr>
                                <td><strong>A typical call</strong></td>
                                <td><code>GET /api/accounts/123</code></td>
                                <td><code>BAPI_CUSTOMER_GETDETAIL(CUSTOMERNO='123')</code></td>
                            </tr>
                            <tr>
                                <td><strong>Transport</strong></td>
                                <td>HTTP over TCP port 80/443</td>
                                <td>RFC over TCP port 3300-3399</td>
                            </tr>
                            <tr>
                                <td><strong>Data format</strong></td>
                                <td>JSON / XML (text, human readable)</td>
                                <td>SAP's binary format (not human readable)</td>
                            </tr>
                            <tr>
                                <td><strong>Open standard?</strong></td>
                                <td style="color:#27ae60; font-weight:bold;">YES &mdash; anyone can use HTTP</td>
                                <td style="color:#e74c3c; font-weight:bold;">NO &mdash; SAP proprietary</td>
                            </tr>
                            <tr>
                                <td><strong>Library needed</strong></td>
                                <td>None (curl, browser, any HTTP client)</td>
                                <td>SAP JCo (Java) or PyRFC (Python) + SAP NW RFC SDK</td>
                            </tr>
                            <tr>
                                <td><strong>Can you test with curl?</strong></td>
                                <td style="color:#27ae60;">Yes: <code>curl https://api.example.com/accounts</code></td>
                                <td style="color:#e74c3c;">No &mdash; binary protocol, needs special library</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>What Happens During an RFC Call vs REST Call</h3>
                <div class="code-block">
<span class="success">REST API Call (web world — what you know):</span>
<span class="dim">─────────────────────────────────────────────────────────</span>
  Client sends:    <span class="variable">GET</span> https://api.salesforce.com/Account/001
  Server returns:  <span class="string">{ "Name": "Acme", "Industry": "Tech" }</span>
  Protocol:        <span class="success">HTTP (text-based, open standard)</span>
  You can see it:  <span class="success">YES — in browser, Postman, curl</span>


<span class="warn">RFC Call (SAP world):</span>
<span class="dim">─────────────────────────────────────────────────────────</span>
  Client sends:    <span class="variable">CALL</span> Z_SNAP_IDOC_READ_COMPLETELY(
                       DOCUMENT_NUMBER = <span class="string">'0000001234'</span>
                   )
  Server returns:  { IDOC_CONTROL: {...}, INT_EDIDD: [...] }
  Protocol:        <span class="warn">RFC (binary, proprietary)</span>
  You can see it:  <span class="danger">NO — binary data, needs JCo/PyRFC to decode</span></div>

                <h3>Why SAP Uses RFC Instead of HTTP</h3>
                <p>SAP was built in the <strong>1990s</strong>, long before REST APIs existed. Every enterprise vendor created their own communication protocol back then:</p>

                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>Year</th><th>Technology</th><th>Protocol</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>1992</strong></td>
                                <td>SAP R/3 launched</td>
                                <td><span class="warn">RFC (proprietary binary)</span></td>
                            </tr>
                            <tr>
                                <td>1998</td>
                                <td>CORBA / Java RMI</td>
                                <td>Binary RPC protocols</td>
                            </tr>
                            <tr>
                                <td>2000</td>
                                <td>SOAP Web Services</td>
                                <td>XML over HTTP</td>
                            </tr>
                            <tr>
                                <td><strong>2010+</strong></td>
                                <td>REST APIs become standard</td>
                                <td><span class="success">JSON over HTTP</span></td>
                            </tr>
                            <tr style="background:#f0fff0;">
                                <td><strong>2015+</strong></td>
                                <td>SAP S/4HANA (new SAP)</td>
                                <td><span class="success">OData (REST/HTTP)</span> &larr; SAP finally moves to HTTP!</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="info-box" style="background:#fff3e0; border-left-color:#e67e22;">
                    <strong>Key takeaway:</strong> RFC exists because SAP was built before HTTP became the standard. SAP's newer products (S/4HANA) use HTTP/OData. But millions of existing systems still use RFC, which is why SnapLogic still has RFC-based SAP snaps.
                </div>

                <h3>Types of RFC</h3>
                <p>SAP has evolved RFC over the years. The main types are:</p>

                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>RFC Type</th><th>How It Works</th><th>REST Equivalent</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>sRFC</strong> (Synchronous)</td>
                                <td>Call a function and <strong>wait</strong> for the response. Blocks until done.</td>
                                <td>Normal REST call: <code>GET /api/data</code> &rarr; wait &rarr; response</td>
                            </tr>
                            <tr>
                                <td><strong>aRFC</strong> (Asynchronous)</td>
                                <td>Call a function and <strong>don't wait</strong>. Continue working. Get result later.</td>
                                <td>Fire-and-forget: <code>POST /api/jobs</code> &rarr; poll for result</td>
                            </tr>
                            <tr>
                                <td><strong>tRFC</strong> (Transactional)</td>
                                <td>Guaranteed <strong>exactly-once</strong> delivery. SAP retries until confirmed.</td>
                                <td>Message queue with guaranteed delivery (like Kafka)</td>
                            </tr>
                            <tr>
                                <td><strong>qRFC</strong> (Queued)</td>
                                <td>Like tRFC but also guarantees <strong>order</strong> of execution.</td>
                                <td>Ordered message queue (like Kafka with partitions)</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <p>SnapLogic's SAP IDoc Read snap uses <strong>sRFC</strong> (synchronous) &mdash; it calls the function and waits for the IDoc data to come back.</p>

                <h3>What Travels Over the Wire</h3>
                <p>An RFC call over the network looks like this:</p>

                <div class="code-block">
<span class="label">SnapLogic (Client) sends this over TCP port 3300:</span>
<span class="dim">┌─────────────────────────────────────────────────────┐</span>
<span class="dim">│</span> <span class="warn">RFC Header</span>                                          <span class="dim">│</span>
<span class="dim">│</span>   Function Name: Z_SNAP_IDOC_READ_COMPLETELY        <span class="dim">│</span>
<span class="dim">│</span>   SysID: DEV, Client: 100, User: SNAP_USER          <span class="dim">│</span>
<span class="dim">├─────────────────────────────────────────────────────┤</span>
<span class="dim">│</span> <span class="variable">Import Parameters</span> (binary encoded)                   <span class="dim">│</span>
<span class="dim">│</span>   DOCUMENT_NUMBER = '0000001234'                     <span class="dim">│</span>
<span class="dim">└─────────────────────────────────────────────────────┘</span>

         <span class="dim">│</span>  Binary data over TCP (NOT HTTP!)
         <span class="dim">v</span>

<span class="label">SAP Server (or PyRFC Mock) sends back:</span>
<span class="dim">┌─────────────────────────────────────────────────────┐</span>
<span class="dim">│</span> <span class="success">RFC Response</span>                                         <span class="dim">│</span>
<span class="dim">│</span>   IDOC_CONTROL: { DOCNUM: '0000001234', ... }       <span class="dim">│</span>
<span class="dim">│</span>   INT_EDIDD: [ { SEGNAM: 'E1EDK01', ... }, ... ]    <span class="dim">│</span>
<span class="dim">│</span>   INT_EDIDS: [ { STATUS: '53', ... } ]              <span class="dim">│</span>
<span class="dim">│</span>   NUMBER_OF_DATA_RECORDS: 5                          <span class="dim">│</span>
<span class="dim">└─────────────────────────────────────────────────────┘</span></div>

                <h3>Libraries That Speak RFC</h3>
                <p>Since RFC is proprietary, you need a special library to speak it. All of them wrap the same SAP C library:</p>

                <div class="code-block">
<span class="label">All RFC libraries wrap the same core:</span>

  <span class="match">SAP NW RFC SDK</span> (C library — the engine)
       <span class="dim">│</span>
       <span class="dim">├──</span> <span class="warn">JCo</span>   = Java wrapper   <span class="comment">← SnapLogic uses this (client)</span>
       <span class="dim">│</span>
       <span class="dim">├──</span> <span class="success">PyRFC</span> = Python wrapper  <span class="comment">← Our mock server uses this (server)</span>
       <span class="dim">│</span>
       <span class="dim">├──</span> NCo   = .NET wrapper    <span class="comment">← For C#/.NET applications</span>
       <span class="dim">│</span>
       <span class="dim">└──</span> ABAP  = Native SAP      <span class="comment">← Runs inside SAP itself</span>

<span class="match">They all produce the SAME binary RFC protocol on the wire.</span>
<span class="match">JCo client ↔ PyRFC server works because the protocol is identical.</span></div>

                <h3>Why This Matters for Mocking</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th></th><th>REST API (Salesforce)</th><th>RFC (SAP)</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Can Django handle it?</strong></td>
                                <td style="color:#27ae60; font-weight:bold;">YES &mdash; Django speaks HTTP</td>
                                <td style="color:#e74c3c; font-weight:bold;">NO &mdash; Django only speaks HTTP</td>
                            </tr>
                            <tr>
                                <td><strong>What do we need?</strong></td>
                                <td>Django server</td>
                                <td>PyRFC server (speaks RFC)</td>
                            </tr>
                            <tr>
                                <td><strong>Mock server approach</strong></td>
                                <td>Django views handle HTTP requests</td>
                                <td>PyRFC handlers handle RFC calls</td>
                            </tr>
                            <tr>
                                <td><strong>In-memory database</strong></td>
                                <td>Same <code>database = {}</code> pattern</td>
                                <td>Same <code>sap_database = {}</code> pattern</td>
                            </tr>
                            <tr>
                                <td><strong>Only difference</strong></td>
                                <td>HTTP in, JSON out</td>
                                <td>RFC in, SAP structures out</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="info-box">
                    <strong>Bottom line:</strong> RFC is just the transport pipe. Our smart mock pattern (in-memory database, CRUD handlers, reset between tests) stays <strong>identical</strong> &mdash; only the protocol layer changes from HTTP to RFC.
                </div>
            </div>
        </div>

        <!-- ═══════════════════════════════════════════════════════════════
             TAB 5: RFC vs ODATA
             ═══════════════════════════════════════════════════════════════ -->
        <div id="rfc-vs-odata" class="tab-content">
            <div class="data-section">
                <h2>RFC vs OData &mdash; The Critical Difference <span class="badge orange">Protocol</span></h2>

                <p>This is the most important thing to understand for mocking. SAP has <strong>two fundamentally different protocols</strong> for external communication:</p>

                <div class="comparison">
                    <div class="comparison-col danger">
                        <h4>RFC (Remote Function Call)</h4>
                        <p style="font-size:12px; margin:0;"><strong>Protocol:</strong> Proprietary binary over TCP</p>
                        <p style="font-size:12px; margin:5px 0;"><strong>Port:</strong> 3300-3399</p>
                        <p style="font-size:12px; margin:5px 0;"><strong>Data format:</strong> Binary serialization</p>
                        <p style="font-size:12px; margin:5px 0;"><strong>Library needed:</strong> SAP JCo (native C + Java, licensed)</p>
                        <p style="font-size:12px; margin:5px 0;"><strong>Django can mock?</strong> <span class="status-badge no">NO</span></p>
                    </div>
                    <div class="comparison-col success">
                        <h4>OData (Open Data Protocol)</h4>
                        <p style="font-size:12px; margin:0;"><strong>Protocol:</strong> HTTP/HTTPS (standard REST)</p>
                        <p style="font-size:12px; margin:5px 0;"><strong>Port:</strong> 443 (standard HTTPS)</p>
                        <p style="font-size:12px; margin:5px 0;"><strong>Data format:</strong> JSON or XML</p>
                        <p style="font-size:12px; margin:5px 0;"><strong>Library needed:</strong> Any HTTP client</p>
                        <p style="font-size:12px; margin:5px 0;"><strong>Django can mock?</strong> <span class="status-badge yes">YES</span></p>
                    </div>
                </div>

                <h3>Protocol Stack Comparison</h3>
                <div class="code-block">
<span class="danger">RFC Protocol Stack:</span>                        <span class="success">OData Protocol Stack:</span>

<span class="dim">+---------------------------+</span>              <span class="dim">+---------------------------+</span>
<span class="dim">|</span> <span class="warn">RFC (Application Layer)</span>  <span class="dim">|</span>              <span class="dim">|</span> <span class="success">OData (Application Layer)</span><span class="dim">|</span>
<span class="dim">|</span> Function calls, params    <span class="dim">|</span>              <span class="dim">|</span> REST endpoints, JSON      <span class="dim">|</span>
<span class="dim">+---------------------------+</span>              <span class="dim">+---------------------------+</span>
<span class="dim">|</span> <span class="warn">CPI-C (Session Layer)</span>    <span class="dim">|</span>              <span class="dim">|</span> <span class="success">HTTP/HTTPS</span>               <span class="dim">|</span>
<span class="dim">|</span> Proprietary session mgmt  <span class="dim">|</span>              <span class="dim">|</span> Standard web protocol     <span class="dim">|</span>
<span class="dim">+---------------------------+</span>              <span class="dim">+---------------------------+</span>
<span class="dim">|</span> <span class="variable">TCP/IP</span>                   <span class="dim">|</span>              <span class="dim">|</span> <span class="variable">TCP/IP</span>                   <span class="dim">|</span>
<span class="dim">|</span> Port 3300-3399            <span class="dim">|</span>              <span class="dim">|</span> Port 443 (HTTPS)          <span class="dim">|</span>
<span class="dim">+---------------------------+</span>              <span class="dim">+---------------------------+</span>

<span class="danger">NOT HTTP! Django cannot</span>                    <span class="success">Standard HTTP! Django</span>
<span class="danger">understand this protocol.</span>                   <span class="success">handles this perfectly.</span></div>

                <h3>Full Comparison Table</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>Aspect</th><th>RFC</th><th>OData</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Protocol</strong></td>
                                <td>Proprietary binary over TCP</td>
                                <td>HTTP/HTTPS (REST)</td>
                            </tr>
                            <tr>
                                <td><strong>Data Format</strong></td>
                                <td>Binary serialization (proprietary)</td>
                                <td>JSON or XML (Atom)</td>
                            </tr>
                            <tr>
                                <td><strong>Port</strong></td>
                                <td>3300-3399 (SAP Gateway)</td>
                                <td>443 (HTTPS) or 8000-8099</td>
                            </tr>
                            <tr>
                                <td><strong>Library Required</strong></td>
                                <td>SAP JCo (Java + native C, licensed)</td>
                                <td>Any HTTP client (curl, requests, etc.)</td>
                            </tr>
                            <tr>
                                <td><strong>Firewall Friendly</strong></td>
                                <td>No (proprietary ports)</td>
                                <td>Yes (standard HTTPS)</td>
                            </tr>
                            <tr>
                                <td><strong>Performance</strong></td>
                                <td>Faster (binary, optimized)</td>
                                <td>Slower (HTTP overhead, text-based)</td>
                            </tr>
                            <tr>
                                <td><strong>Era</strong></td>
                                <td>1990s (legacy but still widely used)</td>
                                <td>2010s+ (modern, S/4HANA standard)</td>
                            </tr>
                            <tr>
                                <td><strong>Mock with Django?</strong></td>
                                <td style="color:#e74c3c; font-weight:bold;">NO</td>
                                <td style="color:#27ae60; font-weight:bold;">YES</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>How RFC Communication Works (JCo)</h3>
                <div class="code-block">
<span class="url-host">SnapLogic Pipeline</span>
    <span class="dim">|</span>
    <span class="dim">v</span>
<span class="url-host">SAP IDoc Read Snap</span>
    <span class="dim">|</span>
    <span class="dim">v</span>
<span class="warn">SAP IDoc Java Library</span> (com.sap.conn.idoc)
    <span class="dim">|</span>
    <span class="dim">v</span>
<span class="warn">SAP JCo Library</span> (com.sap.conn.jco)          <span class="comment">Licensed, native C + Java</span>
    <span class="dim">|</span>
    <span class="dim">v</span>
<span class="danger">Proprietary RFC/CPI-C Binary Protocol</span>       <span class="comment">NOT HTTP!</span>
    <span class="dim">|</span>       over TCP port 33xx
    <span class="dim">v</span>
<span class="url-host">SAP Application Server</span> (Gateway)
    <span class="dim">|</span>
    <span class="dim">v</span>
<span class="variable">Z_SNAP_IDOC_READ_COMPLETELY</span>                 <span class="comment">Custom RFC function</span>
    <span class="dim">|</span>
    <span class="dim">v</span>
IDoc Database Tables (EDIDC, EDID4, EDIDS)</div>

                <div class="info-box red">
                    <strong>Why Django can't mock RFC:</strong> Django speaks HTTP. SAP JCo speaks a proprietary binary protocol. It's like trying to answer a phone call with a fax machine &mdash; they're completely different communication systems.
                </div>
            </div>
        </div>

        <!-- ═══════════════════════════════════════════════════════════════
             TAB 5: CAN WE MOCK SAP?
             ═══════════════════════════════════════════════════════════════ -->
        <div id="can-we-mock" class="tab-content">
            <div class="data-section">
                <h2>Can We Mock SAP with Django? <span class="badge red">Key Decision</span></h2>

                <p>The answer depends on <strong>which SAP protocol</strong> you need to mock:</p>

                <div class="info-box red">
                    <strong>Critical finding:</strong> SAP IDoc Read/Write snaps use <strong>proprietary RFC binary protocol</strong>, NOT HTTP. This means we <strong>cannot</strong> mock them with Django, WireMock, or any HTTP-based mock server.
                </div>

                <h3>Visual Comparison: Salesforce vs SAP</h3>
                <div class="code-block">
<span class="success">SALESFORCE</span> (what we already mocked):

<span class="dim">+----------------+</span>     <span class="success">HTTP/HTTPS (REST)</span>          <span class="dim">+-------------------+</span>
<span class="dim">|</span>  SnapLogic     <span class="dim">|</span>  <span class="success">══════════════════════►</span>  <span class="dim">|</span>  Salesforce.com   <span class="dim">|</span>
<span class="dim">|</span>  Pipeline      <span class="dim">|</span>     Standard port 443       <span class="dim">|</span>  (or Django Mock) <span class="dim">|</span>
<span class="dim">+----------------+</span>     JSON request/response     <span class="dim">+-------------------+</span>

<span class="success">&check; Can mock with Django!</span>


<span class="danger">SAP IDoc</span> (what your screenshots show):

<span class="dim">+----------------+</span>     <span class="danger">RFC Binary Protocol</span>        <span class="dim">+-------------------+</span>
<span class="dim">|</span>  SnapLogic     <span class="dim">|</span>  <span class="danger">══════════════════════►</span>  <span class="dim">|</span>  SAP System       <span class="dim">|</span>
<span class="dim">|</span>  Pipeline      <span class="dim">|</span>     SAP JCo native library   <span class="dim">|</span>  (port 3300)      <span class="dim">|</span>
<span class="dim">+----------------+</span>     TCP port 33xx              <span class="dim">+-------------------+</span>

<span class="danger">&cross; CANNOT mock with Django!</span>


<span class="success">SAP S/4HANA OData</span> (the mockable alternative):

<span class="dim">+----------------+</span>     <span class="success">HTTP/HTTPS (OData REST)</span>    <span class="dim">+-------------------+</span>
<span class="dim">|</span>  SnapLogic     <span class="dim">|</span>  <span class="success">══════════════════════►</span>  <span class="dim">|</span>  SAP S/4HANA      <span class="dim">|</span>
<span class="dim">|</span>  Pipeline      <span class="dim">|</span>     Standard port 443       <span class="dim">|</span>  (or Django Mock) <span class="dim">|</span>
<span class="dim">+----------------+</span>     JSON request/response     <span class="dim">+-------------------+</span>

<span class="success">&check; Can mock with Django!</span></div>

                <h3>Mocking Options for SAP</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>Option</th><th>SAP Protocol</th><th>Difficulty</th><th>Django?</th><th>Notes</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>SAP S/4HANA OData</strong></td>
                                <td>HTTP/REST</td>
                                <td style="color:#27ae60; font-weight:bold;">Easy</td>
                                <td><span class="status-badge yes">YES</span></td>
                                <td>Same approach as Salesforce mock. Just different URL patterns.</td>
                            </tr>
                            <tr>
                                <td><strong>SAP IDoc via RFC</strong></td>
                                <td>Proprietary binary</td>
                                <td style="color:#e74c3c; font-weight:bold;">Very Hard</td>
                                <td><span class="status-badge no">NO</span></td>
                                <td>Needs JCo Server (Java) + licensed SAP libraries</td>
                            </tr>
                            <tr>
                                <td><strong>SAP BAPI via RFC</strong></td>
                                <td>Proprietary binary</td>
                                <td style="color:#e74c3c; font-weight:bold;">Very Hard</td>
                                <td><span class="status-badge no">NO</span></td>
                                <td>Same limitation as IDoc &mdash; RFC is not HTTP</td>
                            </tr>
                            <tr>
                                <td><strong>SAP HANA DB</strong></td>
                                <td>JDBC (database)</td>
                                <td style="color:#e67e22; font-weight:bold;">Medium</td>
                                <td><span class="status-badge partial">Partial</span></td>
                                <td>Could mock with PostgreSQL + matching schema</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Why RFC Can't Be Mocked with Django/WireMock</h3>

                <div class="flow-step">
                    <div class="flow-number red">1</div>
                    <div class="flow-content">
                        <h4>Django/WireMock speak HTTP</h4>
                        <p>They listen on a port and expect HTTP requests (GET, POST, PATCH, etc.) with headers, JSON/XML bodies.</p>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number red">2</div>
                    <div class="flow-content">
                        <h4>SAP JCo speaks RFC binary protocol</h4>
                        <p>It sends proprietary binary-serialized function calls over TCP. Not HTTP headers, not JSON, not anything a web server can understand.</p>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number red">3</div>
                    <div class="flow-content">
                        <h4>You can't redirect the SAP snap to an HTTP endpoint</h4>
                        <p>The SAP IDoc Read snap is hardcoded to use JCo library &rarr; RFC protocol. You can change the <strong>hostname</strong>, but the snap will still try to speak RFC binary to that host. Django won't understand a single byte of it.</p>
                    </div>
                </div>

                <div class="info-box">
                    <strong>Recommendation:</strong> Focus on mocking <strong>SAP S/4HANA OData</strong> endpoints (HTTP-based) with Django. For SAP IDoc/BAPI (RFC), there ARE options &mdash; see the <strong>"RFC Mocking Options"</strong> tab for PyRFC (Python), JCo Server (Java), Pipeline Bypass, and Hybrid approaches.
                </div>
            </div>
        </div>

        <!-- ═══════════════════════════════════════════════════════════════
             TAB 5B: RFC MOCKING OPTIONS
             ═══════════════════════════════════════════════════════════════ -->
        <div id="rfc-mock-options" class="tab-content">
            <div class="data-section">
                <h2>RFC Mocking Options &mdash; Yes, It IS Possible! <span class="badge">Solutions</span></h2>

                <p>While Django alone cannot mock SAP RFC protocol, there <strong>are</strong> ways to mock SAP IDoc/BAPI snaps. Here are all the options, from easiest to most complex:</p>

                <div class="info-box">
                    <strong>Key insight:</strong> Instead of trying to mock SAP's proprietary binary protocol, the cleanest approach is to <strong>mock at the SnapLogic layer</strong> (Option 1) &mdash; capture a real IDoc response and replay it. For true RFC-level testing, the most promising path is <strong>Snap Mock Mode</strong> (Option 6) &mdash; intercept inside the snap at the XML layer before binary encoding, and redirect to a Django mock server. Raw TCP binary mocking (Option 3) is <strong>not viable</strong> because the RFC protocol is proprietary.
                </div>
            </div>

            <!-- Option 1: Mock at SnapLogic Layer (RECOMMENDED) -->
            <div class="data-section">
                <h2>Option 1: Mock at the SnapLogic Layer <span class="badge">Recommended</span></h2>

                <p>Instead of mocking the SAP protocol, <strong>mock the output of the SAP IDoc Snap</strong>. This is the cleanest approach for Robot Framework automation, CI pipelines, and local testing.</p>

                <div class="info-box">
                    <strong>The idea:</strong> Capture a real IDoc response once from a Dev/lower environment, save it as a JSON file, then replace the SAP Snap with a File Reader or JSON Generator that replays that response. The pipeline downstream doesn't know the difference.
                </div>

                <h3>How It Works</h3>

                <div class="flow-step">
                    <div class="flow-number">1</div>
                    <div class="flow-content">
                        <h4>Capture a real IDoc response</h4>
                        <p>Run the pipeline once against a real SAP Dev/QA environment. Capture the output of the SAP IDoc Read snap as JSON or XML.</p>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number blue">2</div>
                    <div class="flow-content">
                        <h4>Save it as a mock data file</h4>
                        <p>Store the captured response as a JSON/XML file in your test data directory (e.g., <code>test-data/sap/idoc_orders05_response.json</code>).</p>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number purple">3</div>
                    <div class="flow-content">
                        <h4>Replace the SAP Snap with a mock source</h4>
                        <p>In the test version of the pipeline, replace the SAP IDoc Read snap with one of: <strong>File Reader Snap</strong>, <strong>JSON Generator</strong>, or a <strong>Mock REST endpoint</strong> (using the Django mock server).</p>
                    </div>
                </div>

                <div class="code-block">
<span class="label">REAL PIPELINE (production):</span>
  JSON Generator <span class="arrow">&rarr;</span> <span class="danger">SAP IDoc Read</span> <span class="arrow">&rarr;</span> Mapper <span class="arrow">&rarr;</span> Transformer <span class="arrow">&rarr;</span> Target
                     <span class="dim">|</span>
                     <span class="dim">| Calls SAP via RFC (proprietary binary)</span>
                     <span class="dim">v</span>
                  <span class="dim">Real SAP System</span>


<span class="label">TEST PIPELINE (for Robot Framework / CI):</span>
  JSON Generator <span class="arrow">&rarr;</span> <span class="match">File Reader / JSON Generator</span> <span class="arrow">&rarr;</span> Mapper <span class="arrow">&rarr;</span> Transformer <span class="arrow">&rarr;</span> Target
                     <span class="dim">|</span>
                     <span class="dim">| Reads captured IDoc response from JSON file</span>
                     <span class="dim">v</span>
                  <span class="match">test-data/sap/idoc_orders05_response.json</span>
                  <span class="success">No SAP system needed! No special libraries!</span></div>

                <h3>Example: Captured IDoc Response (JSON)</h3>
                <div class="code-label">test-data/sap/idoc_orders05_response.json</div>
                <div class="code-block">
{
  <span class="string">"IDOC_CONTROL"</span>: {
    <span class="string">"DOCNUM"</span>: <span class="string">"0000000012345"</span>,
    <span class="string">"IDOCTP"</span>: <span class="string">"ORDERS05"</span>,
    <span class="string">"MESTYP"</span>: <span class="string">"ORDERS"</span>,
    <span class="string">"STATUS"</span>: <span class="string">"53"</span>,
    <span class="string">"SNDPRN"</span>: <span class="string">"EXTSYSTEM"</span>,
    <span class="string">"RCVPRN"</span>: <span class="string">"SAPCLNT100"</span>
  },
  <span class="string">"DATA_RECORDS"</span>: [
    { <span class="string">"SEGNAM"</span>: <span class="string">"E1EDK01"</span>, <span class="string">"HLEVEL"</span>: <span class="string">"1"</span>, <span class="string">"SDATA"</span>: <span class="string">"..."</span> },
    { <span class="string">"SEGNAM"</span>: <span class="string">"E1EDP01"</span>, <span class="string">"HLEVEL"</span>: <span class="string">"2"</span>, <span class="string">"SDATA"</span>: <span class="string">"..."</span> }
  ],
  <span class="string">"STATUS_RECORDS"</span>: [
    { <span class="string">"STATUS"</span>: <span class="string">"53"</span>, <span class="string">"STATTEXT"</span>: <span class="string">"Application document posted"</span> }
  ]
}</div>

                <h3>Best For</h3>
                <div class="table-container">
                    <table>
                        <thead><tr><th>Use Case</th><th>Why This Works</th></tr></thead>
                        <tbody>
                            <tr><td><strong>Robot Framework automation</strong></td><td>Tests run without SAP — just read mock data from file</td></tr>
                            <tr><td><strong>CI/CD pipelines</strong></td><td>No SAP license or connectivity needed in CI environments</td></tr>
                            <tr><td><strong>Local development</strong></td><td>Develop and test mappers/transformers without waiting for SAP</td></tr>
                            <tr><td><strong>Downstream testing</strong></td><td>Test everything after the SAP snap (mappers, transforms, target writes)</td></tr>
                            <tr><td><strong>Edge case testing</strong></td><td>Create mock files with error responses, empty IDocs, malformed data</td></tr>
                        </tbody>
                    </table>
                </div>

                <div class="table-container">
                    <table>
                        <thead><tr><th>Pros</th><th>Cons</th></tr></thead>
                        <tbody>
                            <tr><td style="color:#27ae60;">No mock server needed at all</td><td>Need to maintain a test pipeline variant</td></tr>
                            <tr><td style="color:#27ae60;">No SAP libraries or SDK required</td><td>Not testing the actual SAP RFC connectivity</td></tr>
                            <tr><td style="color:#27ae60;">Works today, zero setup, zero cost</td><td>Can't test account validation or connection handling</td></tr>
                            <tr><td style="color:#27ae60;">Real data from real SAP (captured once)</td><td>Need to re-capture if SAP schema changes</td></tr>
                            <tr><td style="color:#27ae60;">Can test error scenarios with crafted mock files</td><td>Doesn't test the full end-to-end RFC path</td></tr>
                            <tr><td style="color:#27ae60;">Works in CI, Docker, local — anywhere</td><td>&mdash;</td></tr>
                        </tbody>
                    </table>
                </div>

                <h3>Alternative: Pipeline-Level Bypass</h3>
                <p>Instead of capturing mock data into a file, you can also <strong>bypass the SAP snap entirely</strong> and inject mock data directly in the pipeline using a JSON Generator or JSON Parser snap:</p>

                <div class="code-block">
<span class="label">REAL PIPELINE:</span>
  JSON Generator <span class="arrow">&rarr;</span> <span class="danger">SAP IDoc Read</span> <span class="arrow">&rarr;</span> Mapper <span class="arrow">&rarr;</span> Target
                     <span class="dim">|</span>
                     <span class="dim">| Calls SAP via RFC</span>
                     <span class="dim">v</span>
                  <span class="dim">SAP System</span>


<span class="label">TEST PIPELINE (modified):</span>
  JSON Generator <span class="arrow">&rarr;</span> <span class="match">JSON Parser (mock IDoc data)</span> <span class="arrow">&rarr;</span> Mapper <span class="arrow">&rarr;</span> Target
                     <span class="dim">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
                     <span class="match">Replace SAP snap with a JSON file</span>
                     <span class="match">containing the same output format</span>
                     <span class="success">No SAP system needed!</span></div>

                <p>Both approaches (File Reader with captured data OR JSON Generator/Parser with inline data) achieve the same goal &mdash; <strong>test everything downstream of the SAP snap without needing SAP</strong>. Choose whichever fits your workflow better. Pure SnapLogic, no Docker complexity.</p>

                <div class="info-box">
                    <strong>This is the recommended starting point</strong> for SAP IDoc/BAPI mocking. It gives you 90% of the testing value with 10% of the effort. For the remaining 10% (actual RFC connectivity testing), see Options 2-7 below.
                </div>
            </div>

            <!-- Option 2: PyRFC Smart Mock -->
            <div class="data-section">
                <h2>Option 2: PyRFC Smart Mock Server (Python) <span class="badge blue">Advanced</span></h2>

                <p><strong>PyRFC</strong> is an open-source Python library that wraps SAP's C-based RFC SDK. It can work in <strong>server mode</strong> &mdash; listening for incoming RFC calls. We build it as a <strong>stateful smart mock</strong> with an in-memory database, exactly like our Salesforce Django mock server.</p>

                <div class="info-box" style="background:#fff3e0; border-left-color:#e67e22;">
                    <strong>Design Principle:</strong> No WireMock-style hardcoded responses. Every BAPI/RFC handler reads from and writes to an <strong>in-memory Python dict</strong> &mdash; the same pattern as our Salesforce mock. You can Create an IDoc, Read it back, Update it, Delete it, and verify the full CRUD lifecycle in Robot Framework tests.
                </div>

                <div class="code-block">
<span class="url-host">SnapLogic Pipeline</span>                           <span class="match">PyRFC Smart Mock Server</span>

<span class="dim">+----------------+</span>     <span class="variable">RFC Protocol</span>          <span class="dim">+---------------------------------------+</span>
<span class="dim">|</span>  SAP IDoc      <span class="dim">|</span>  <span class="arrow">══════════════════►</span>  <span class="dim">|</span>  Python PyRFC Server                  <span class="dim">|</span>
<span class="dim">|</span>  Read Snap     <span class="dim">|</span>     Port 33xx            <span class="dim">|</span>                                       <span class="dim">|</span>
<span class="dim">|</span>                <span class="dim">|</span>     Proprietary binary   <span class="dim">|</span>  <span class="match">RFC Handler Functions</span>                <span class="dim">|</span>
<span class="dim">+----------------+</span>                           <span class="dim">|</span>       <span class="dim">|</span>                                <span class="dim">|</span>
                                              <span class="dim">|</span>       <span class="dim">v</span>                                <span class="dim">|</span>
                                              <span class="dim">|</span>  <span class="success">┌─────────────────────────────┐</span>  <span class="dim">|</span>
                                              <span class="dim">|</span>  <span class="success">│  In-Memory Database (dict)  │</span>  <span class="dim">|</span>
                                              <span class="dim">|</span>  <span class="success">│  sap_database = {           │</span>  <span class="dim">|</span>
                                              <span class="dim">|</span>  <span class="success">│    'IDOC': {...},           │</span>  <span class="dim">|</span>
                                              <span class="dim">|</span>  <span class="success">│    'CUSTOMER': {...},       │</span>  <span class="dim">|</span>
                                              <span class="dim">|</span>  <span class="success">│    'MATERIAL': {...},       │</span>  <span class="dim">|</span>
                                              <span class="dim">|</span>  <span class="success">│  }                          │</span>  <span class="dim">|</span>
                                              <span class="dim">|</span>  <span class="success">└─────────────────────────────┘</span>  <span class="dim">|</span>
                                              <span class="dim">+---------------------------------------+</span></div>

                <h3>In-Memory Database &mdash; Same Pattern as Salesforce</h3>
                <p>Just like our Salesforce mock uses <code>database = {}</code> and <code>schemas = {}</code>, the SAP mock uses the same approach:</p>

                <div class="code-label">sap_state/database.py &mdash; In-Memory SAP Database</div>
                <div class="code-block">
<span class="string">"""
In-Memory SAP Database
======================
Same pattern as salesforce_mock/state/database.py

Module-level dict singletons imported by all RFC handlers.
All data is lost on restart (by design for clean tests).
"""</span>

<span class="comment"># In-memory record storage (same pattern as Salesforce)</span>
<span class="comment"># { 'IDOC': { '0000000001234': {full_idoc}, ... },</span>
<span class="comment">#   'CUSTOMER': { 'CUST001': {customer_data}, ... },</span>
<span class="comment">#   'MATERIAL': { 'MAT001': {material_data}, ... } }</span>
sap_database = {
    <span class="string">'IDOC'</span>: {},
    <span class="string">'CUSTOMER'</span>: {},
    <span class="string">'MATERIAL'</span>: {},
    <span class="string">'SALES_ORDER'</span>: {},
}

<span class="comment"># Auto-increment counters for generating SAP-style document numbers</span>
_counters = {
    <span class="string">'IDOC'</span>: 1000000000,
    <span class="string">'SALES_ORDER'</span>: 5000000000,
}

<span class="keyword">def</span> <span class="function">generate_doc_number</span>(doc_type):
    <span class="string">"""Generate SAP-style sequential document number (10 digits, zero-padded)."""</span>
    _counters[doc_type] = _counters.get(doc_type, 1000000000) + 1
    <span class="keyword">return</span> str(_counters[doc_type]).zfill(10)


<span class="keyword">def</span> <span class="function">reset_all</span>():
    <span class="string">"""Clear all records (called between tests for clean state)."""</span>
    total = 0
    <span class="keyword">for</span> key <span class="keyword">in</span> sap_database:
        total += len(sap_database[key])
        sap_database[key] = {}
    <span class="keyword">for</span> key <span class="keyword">in</span> _counters:
        _counters[key] = 1000000000
    <span class="keyword">return</span> total</div>

                <h3>CRUD RFC Handlers &mdash; Stateful, Not Hardcoded</h3>
                <p>Each SAP BAPI/RFC function is mapped to a handler that reads from or writes to the in-memory database:</p>

                <div class="code-label">sap_handlers/idoc_handlers.py &mdash; IDoc CRUD Operations</div>
                <div class="code-block">
<span class="keyword">from</span> sap_state.database <span class="keyword">import</span> sap_database, generate_doc_number

<span class="comment"># ═══════════════════════════════════════════════════</span>
<span class="comment"># CREATE &mdash; Store a new IDoc in the in-memory database</span>
<span class="comment"># ═══════════════════════════════════════════════════</span>
<span class="keyword">def</span> <span class="function">handle_idoc_send</span>(request_context, <span class="variable">IDOC_CONTROL</span>, <span class="variable">IDOC_DATA</span>):
    <span class="string">"""BAPI: IDOC_INBOUND_ASYNCHRONOUS &mdash; Create/Send an IDoc"""</span>
    doc_num = generate_doc_number(<span class="string">'IDOC'</span>)

    <span class="comment"># Store in in-memory database (just like Salesforce's database['Account'].append(record))</span>
    sap_database[<span class="string">'IDOC'</span>][doc_num] = {
        <span class="string">'IDOC_CONTROL'</span>: {
            <span class="string">'DOCNUM'</span>: doc_num,
            <span class="string">'IDOCTP'</span>: IDOC_CONTROL.get(<span class="string">'IDOCTP'</span>, <span class="string">'ORDERS05'</span>),
            <span class="string">'MESTYP'</span>: IDOC_CONTROL.get(<span class="string">'MESTYP'</span>, <span class="string">'ORDERS'</span>),
            <span class="string">'STATUS'</span>: <span class="string">'53'</span>,
            <span class="string">'SNDPRN'</span>: IDOC_CONTROL.get(<span class="string">'SNDPRN'</span>, <span class="string">'EXTSYSTEM'</span>),
            <span class="string">'RCVPRN'</span>: IDOC_CONTROL.get(<span class="string">'RCVPRN'</span>, <span class="string">'SAPCLNT100'</span>),
            <span class="string">'CREDAT'</span>: datetime.now().strftime(<span class="string">'%Y%m%d'</span>),
            <span class="string">'CRETIM'</span>: datetime.now().strftime(<span class="string">'%H%M%S'</span>),
        },
        <span class="string">'INT_EDIDD'</span>: IDOC_DATA,
        <span class="string">'INT_EDIDS'</span>: [
            {<span class="string">'STATUS'</span>: <span class="string">'53'</span>, <span class="string">'STATTEXT'</span>: <span class="string">'Application document posted'</span>}
        ],
    }

    print(f<span class="string">'  ✅ Created IDoc: {doc_num}'</span>)
    <span class="keyword">return</span> {<span class="string">'DOCNUM'</span>: doc_num, <span class="string">'STATUS'</span>: <span class="string">'53'</span>, <span class="string">'STATUS_TEXT'</span>: <span class="string">'Success'</span>}


<span class="comment"># ═══════════════════════════════════════════════════</span>
<span class="comment"># READ &mdash; Look up IDoc from the in-memory database</span>
<span class="comment"># ═══════════════════════════════════════════════════</span>
<span class="keyword">def</span> <span class="function">handle_idoc_read</span>(request_context, <span class="variable">DOCUMENT_NUMBER</span>):
    <span class="string">"""BAPI: Z_SNAP_IDOC_READ_COMPLETELY &mdash; Read an IDoc by document number"""</span>
    idoc = sap_database[<span class="string">'IDOC'</span>].get(DOCUMENT_NUMBER)

    <span class="keyword">if not</span> idoc:
        print(f<span class="string">'  ❌ IDoc not found: {DOCUMENT_NUMBER}'</span>)
        <span class="keyword">return</span> {
            <span class="string">'ERROR'</span>: {<span class="string">'MESSAGE'</span>: f<span class="string">'IDoc {DOCUMENT_NUMBER} does not exist'</span>},
            <span class="string">'NUMBER_OF_DATA_RECORDS'</span>: 0,
        }

    print(f<span class="string">'  ✅ Read IDoc: {DOCUMENT_NUMBER}'</span>)
    <span class="keyword">return</span> {
        <span class="string">'IDOC_CONTROL'</span>: idoc[<span class="string">'IDOC_CONTROL'</span>],
        <span class="string">'INT_EDIDD'</span>: idoc[<span class="string">'INT_EDIDD'</span>],
        <span class="string">'INT_EDIDS'</span>: idoc[<span class="string">'INT_EDIDS'</span>],
        <span class="string">'NUMBER_OF_DATA_RECORDS'</span>: len(idoc[<span class="string">'INT_EDIDD'</span>]),
        <span class="string">'NUMBER_OF_STATUS_RECORDS'</span>: len(idoc[<span class="string">'INT_EDIDS'</span>]),
    }


<span class="comment"># ═══════════════════════════════════════════════════</span>
<span class="comment"># UPDATE &mdash; Modify an existing IDoc's status/data</span>
<span class="comment"># ═══════════════════════════════════════════════════</span>
<span class="keyword">def</span> <span class="function">handle_idoc_status_update</span>(request_context, <span class="variable">DOCUMENT_NUMBER</span>, <span class="variable">NEW_STATUS</span>):
    <span class="string">"""BAPI: IDOC_STATUS_WRITE_TO_DATABASE &mdash; Update IDoc status"""</span>
    idoc = sap_database[<span class="string">'IDOC'</span>].get(DOCUMENT_NUMBER)

    <span class="keyword">if not</span> idoc:
        <span class="keyword">return</span> {<span class="string">'ERROR'</span>: {<span class="string">'MESSAGE'</span>: f<span class="string">'IDoc {DOCUMENT_NUMBER} does not exist'</span>}}

    <span class="comment"># Update status in the in-memory record</span>
    idoc[<span class="string">'IDOC_CONTROL'</span>][<span class="string">'STATUS'</span>] = NEW_STATUS
    idoc[<span class="string">'INT_EDIDS'</span>].append({
        <span class="string">'STATUS'</span>: NEW_STATUS,
        <span class="string">'STATTEXT'</span>: f<span class="string">'Status changed to {NEW_STATUS}'</span>,
    })

    print(f<span class="string">'  ✅ Updated IDoc {DOCUMENT_NUMBER} status to {NEW_STATUS}'</span>)
    <span class="keyword">return</span> {<span class="string">'SUCCESS'</span>: <span class="string">'X'</span>}


<span class="comment"># ═══════════════════════════════════════════════════</span>
<span class="comment"># DELETE &mdash; Remove IDoc from in-memory database</span>
<span class="comment"># ═══════════════════════════════════════════════════</span>
<span class="keyword">def</span> <span class="function">handle_idoc_delete</span>(request_context, <span class="variable">DOCUMENT_NUMBER</span>):
    <span class="string">"""Remove an IDoc (for test cleanup)"""</span>
    <span class="keyword">if</span> DOCUMENT_NUMBER <span class="keyword">in</span> sap_database[<span class="string">'IDOC'</span>]:
        <span class="keyword">del</span> sap_database[<span class="string">'IDOC'</span>][DOCUMENT_NUMBER]
        print(f<span class="string">'  ✅ Deleted IDoc: {DOCUMENT_NUMBER}'</span>)
        <span class="keyword">return</span> {<span class="string">'SUCCESS'</span>: <span class="string">'X'</span>}
    <span class="keyword">else</span>:
        print(f<span class="string">'  ❌ IDoc not found for delete: {DOCUMENT_NUMBER}'</span>)
        <span class="keyword">return</span> {<span class="string">'ERROR'</span>: {<span class="string">'MESSAGE'</span>: f<span class="string">'IDoc {DOCUMENT_NUMBER} does not exist'</span>}}</div>

                <h3>Server Startup &mdash; Register All Handlers</h3>
                <div class="code-label">sap_server.py &mdash; PyRFC Server with Registered CRUD Handlers</div>
                <div class="code-block">
<span class="keyword">from</span> pyrfc <span class="keyword">import</span> Server
<span class="keyword">from</span> sap_handlers.idoc_handlers <span class="keyword">import</span> (
    handle_idoc_send, handle_idoc_read,
    handle_idoc_status_update, handle_idoc_delete
)

<span class="comment"># Register each BAPI/RFC function to its smart handler</span>
server = Server(
    server_params={<span class="string">'gwhost'</span>: <span class="string">'0.0.0.0'</span>, <span class="string">'gwserv'</span>: <span class="string">'sapgw00'</span>,
                   <span class="string">'program_id'</span>: <span class="string">'MOCK_SAP_SERVER'</span>}
)

<span class="comment"># CRUD operations for IDoc</span>
server.add_function(<span class="string">'Z_SNAP_IDOC_READ_COMPLETELY'</span>, handle_idoc_read)
server.add_function(<span class="string">'IDOC_INBOUND_ASYNCHRONOUS'</span>, handle_idoc_send)
server.add_function(<span class="string">'IDOC_STATUS_WRITE_TO_DATABASE'</span>, handle_idoc_status_update)

<span class="comment"># Admin endpoint (for Robot Framework test cleanup)</span>
server.add_function(<span class="string">'Z_MOCK_RESET_DATABASE'</span>,
    <span class="keyword">lambda</span> ctx: {<span class="string">'RECORDS_CLEARED'</span>: reset_all()})

print(<span class="string">'🚀 SAP PyRFC Smart Mock Server started on port 3300'</span>)
print(<span class="string">'   In-memory database ready (same pattern as Salesforce mock)'</span>)
server.<span class="function">serve</span>()</div>

                <h3>CRUD Test Flow &mdash; Comparing Salesforce vs SAP Mock</h3>
                <p>The test lifecycle is <strong>identical</strong> to how we test with the Salesforce mock:</p>

                <div class="code-block">
<span class="label">SALESFORCE MOCK (what we have today):</span>
<span class="dim">─────────────────────────────────────────────────────────────────</span>
  Step 1: POST /sobjects/Account         <span class="arrow">→</span> <span class="success">Creates record in database['Account']</span>
          Returns: { id: "001xx000003DGb1" }

  Step 2: GET  /sobjects/Account/001xx.. <span class="arrow">→</span> <span class="success">Finds THAT record from dict</span>
          Returns: { Name: "Acme", ... }

  Step 3: SOQL "SELECT * FROM Account"   <span class="arrow">→</span> <span class="success">Queries in-memory dict</span>
          Returns: { records: [...] }

  Step 4: DELETE /sobjects/Account/001xx  <span class="arrow">→</span> <span class="success">Removes from dict</span>
  Step 5: GET    /sobjects/Account/001xx  <span class="arrow">→</span> <span class="danger">404 Not Found!</span>


<span class="label">SAP PyRFC SMART MOCK (same pattern, different protocol):</span>
<span class="dim">─────────────────────────────────────────────────────────────────</span>
  Step 1: RFC IDOC_INBOUND_ASYNCHRONOUS  <span class="arrow">→</span> <span class="success">Creates record in sap_database['IDOC']</span>
          Returns: { DOCNUM: "0000001001" }

  Step 2: RFC Z_SNAP_IDOC_READ_COMPLETELY <span class="arrow">→</span> <span class="success">Finds THAT IDoc from dict</span>
          Returns: { IDOC_CONTROL: {...}, INT_EDIDD: [...] }

  Step 3: RFC IDOC_STATUS_WRITE          <span class="arrow">→</span> <span class="success">Updates status in-memory</span>
          Returns: { SUCCESS: 'X' }

  Step 4: RFC Z_MOCK_DELETE_IDOC          <span class="arrow">→</span> <span class="success">Removes from dict</span>
  Step 5: RFC Z_SNAP_IDOC_READ_COMPLETELY <span class="arrow">→</span> <span class="danger">ERROR: IDoc does not exist!</span>


<span class="match">Same in-memory database pattern. Same CRUD lifecycle. Different protocol.</span></div>

                <h3>Robot Framework Test Example</h3>
                <div class="code-label">How a Robot Framework test would validate the SAP mock CRUD lifecycle</div>
                <div class="code-block">
<span class="label">*** Test Cases ***</span>
<span class="function">Verify SAP IDoc Create And Read Back</span>
    <span class="comment"># Step 1: Pipeline sends IDoc via SAP IDoc Write Snap → mock stores it</span>
    Execute Pipeline    SAP_IDoc_Write_Pipeline

    <span class="comment"># Step 2: Pipeline reads IDoc via SAP IDoc Read Snap → mock returns it from dict</span>
    ${result}=    Execute Pipeline    SAP_IDoc_Read_Pipeline

    <span class="comment"># Step 3: Verify the IDoc we created is the one we got back</span>
    Should Be Equal    ${result.IDOC_CONTROL.IDOCTP}    ORDERS05
    Should Be Equal    ${result.IDOC_CONTROL.STATUS}     53
    Should Not Be Empty    ${result.INT_EDIDD}

<span class="function">Verify SAP Mock Database Resets Between Tests</span>
    <span class="comment"># Call admin reset (same concept as Salesforce mock's /admin/reset)</span>
    Reset SAP Mock Database

    <span class="comment"># Verify the IDoc from previous test is gone</span>
    ${result}=    Execute Pipeline    SAP_IDoc_Read_Pipeline
    Should Contain    ${result.ERROR.MESSAGE}    does not exist</div>

                <h3>File Structure &mdash; Mirrors Salesforce Mock</h3>
                <div class="code-block">
<span class="label">SALESFORCE MOCK (existing):</span>              <span class="label">SAP PyRFC MOCK (to build):</span>
<span class="dim">salesforce_mock/</span>                          <span class="dim">sap_mock/</span>
  <span class="dim">├──</span> state/                                <span class="dim">├──</span> sap_state/
  <span class="dim">│</span>   <span class="dim">├──</span> <span class="success">database.py</span>  <span class="comment"># database={}</span>     <span class="dim">│</span>   <span class="dim">├──</span> <span class="success">database.py</span>  <span class="comment"># sap_database={}</span>
  <span class="dim">│</span>   <span class="dim">├──</span> event_bus.py                      <span class="dim">│</span>   <span class="dim">└──</span> counters.py  <span class="comment"># doc number gen</span>
  <span class="dim">│</span>   <span class="dim">└──</span> job_store.py                      <span class="dim">├──</span> sap_handlers/
  <span class="dim">├──</span> views/                                <span class="dim">│</span>   <span class="dim">├──</span> <span class="success">idoc_handlers.py</span>   <span class="comment"># IDoc CRUD</span>
  <span class="dim">│</span>   <span class="dim">├──</span> <span class="success">rest_views.py</span>  <span class="comment"># CRUD views</span>   <span class="dim">│</span>   <span class="dim">├──</span> <span class="success">bapi_handlers.py</span>   <span class="comment"># BAPI CRUD</span>
  <span class="dim">│</span>   <span class="dim">├──</span> bulk_v1_views.py                  <span class="dim">│</span>   <span class="dim">└──</span> <span class="success">admin_handlers.py</span>  <span class="comment"># reset/status</span>
  <span class="dim">│</span>   <span class="dim">├──</span> bulk_v2_ingest_views.py            <span class="dim">├──</span> <span class="success">sap_server.py</span>          <span class="comment"># PyRFC server start</span>
  <span class="dim">│</span>   <span class="dim">└──</span> ...                                <span class="dim">└──</span> schemas/
  <span class="dim">├──</span> utils/                                     <span class="dim">├──</span> ORDERS05.json  <span class="comment"># IDoc type defs</span>
  <span class="dim">│</span>   <span class="dim">├──</span> id_generator.py                        <span class="dim">└──</span> MATMAS05.json
  <span class="dim">│</span>   <span class="dim">└──</span> validator.py
  <span class="dim">├──</span> urls.py
  <span class="dim">└──</span> settings.py</div>

                <div class="table-container">
                    <table>
                        <thead><tr><th>Pros</th><th>Cons</th></tr></thead>
                        <tbody>
                            <tr><td style="color:#27ae60;">Stateful smart mock &mdash; full CRUD lifecycle, not hardcoded responses</td><td>Requires SAP NW RFC SDK (free download but SAP license check needed)</td></tr>
                            <tr><td style="color:#27ae60;">Python &mdash; fits our stack perfectly, same patterns as Salesforce mock</td><td>Native C library dependency (platform-specific .so/.dll)</td></tr>
                            <tr><td style="color:#27ae60;">In-memory database with reset_all() &mdash; clean state between tests</td><td>More complex setup than Django HTTP mocking</td></tr>
                            <tr><td style="color:#27ae60;">Real RFC protocol &mdash; SAP snap doesn't know it's a mock</td><td>PyRFC server mode has less documentation than client mode</td></tr>
                            <tr><td style="color:#27ae60;">Can mock any BAPI/RFC function with the same handler pattern</td><td>Need to define function metadata (parameter types/structures)</td></tr>
                            <tr><td style="color:#27ae60;">Robot Framework tests can validate Create → Read → Update → Delete</td><td>Requires understanding of SAP IDoc/BAPI data structures</td></tr>
                            <tr><td style="color:#27ae60;">Open source (Apache 2.0 license)</td><td>&mdash;</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Option 3: Raw TCP RFC Mock Server — NOT VIABLE -->
            <div class="data-section">
                <h2>Option 3: Raw TCP RFC Mock Server (Python) <span class="badge" style="background:#95a5a6;">Not Viable</span></h2>

                <p><strong>Original idea:</strong> Build a pure Python TCP socket server that speaks the RFC binary protocol directly on port 3300, with no SAP dependencies at all.</p>

                <div class="info-box" style="background:#fce4ec; border-left-color:#e74c3c;">
                    <strong>Why this is NOT viable:</strong> The RFC protocol is a <strong>proprietary binary encoding mechanism</strong>. You cannot understand the traffic on the network &mdash; it's not like HTTP/JSON where you can read the request in plain text. You would have to reverse-engineer a proprietary format, which is impractical and fragile. The binary encoding is internal to SAP's NW RFC SDK library and is not documented for external implementation.
                </div>

                <h3>Why It Sounded Good (But Isn't)</h3>

                <div class="table-container">
                    <table>
                        <thead><tr><th>What We Thought</th><th>The Reality</th></tr></thead>
                        <tbody>
                            <tr><td>Just parse the binary protocol (~450 lines)</td><td style="color:#e74c3c;">It's a proprietary encoding &mdash; you don't know what the binary means</td></tr>
                            <tr><td>Capture traffic with Wireshark and replay</td><td style="color:#e74c3c;">Wireshark can dissect it, but building a <strong>dynamic</strong> responder from captured bytes is not realistic</td></tr>
                            <tr><td>Same pattern as Salesforce mock (just different protocol)</td><td style="color:#e74c3c;">Salesforce uses HTTP/JSON (open standard). RFC uses proprietary binary (closed format)</td></tr>
                            <tr><td>No SAP dependencies needed</td><td style="color:#e74c3c;">True, but you'd be reimplementing SAP's proprietary serialization &mdash; a massive undertaking</td></tr>
                        </tbody>
                    </table>
                </div>

                <h3>The Key Difference: HTTP vs RFC</h3>

                <div class="code-block">
<span class="label">SALESFORCE (HTTP/JSON) &mdash; you CAN mock this:</span>
<span class="dim">─────────────────────────────────────────────────────</span>
  The snap sends:  <span class="success">POST /sobjects/Account {"Name": "Acme"}</span>
  You can read it: <span class="success">Plain text! Standard HTTP! Well-documented!</span>
  You mock it:     <span class="success">Django returns {"id": "001xx..."} — easy</span>


<span class="label">SAP RFC (Binary) &mdash; you CANNOT mock this:</span>
<span class="dim">─────────────────────────────────────────────────────</span>
  The snap sends:  <span class="danger">0x00 0x1A 0x4F 0xC3 0x02 0xFF 0xE8 0x9B ...</span>
  You can read it: <span class="danger">Binary blob. Proprietary encoding. Undocumented.</span>
  You mock it:     <span class="danger">You can't — you don't know what the bytes mean</span></div>

                <h3>What About the XML Layer?</h3>

                <p>There <strong>is</strong> an XML representation of RFC data. Right before data hits the network and gets serialized to binary, it exists as clean, structured XML. This is used internally by middleware like Apache Camel's SAP component. However:</p>

                <div class="info-box" style="background:#fff8e1; border-left-color:#f57f17;">
                    <strong>The XML exists inside the JCo/SDK library</strong> &mdash; there is no external interception point. The XML &rarr; binary conversion happens within the NW RFC SDK C library itself. You cannot hook into this layer from outside the snap. This is why Option 3 (Snap Mock Mode) takes a different approach &mdash; intercepting <strong>inside</strong> the snap before the binary encoding happens.
                </div>

                <h3>Existing Tools That Were Explored</h3>

                <p>Before concluding this option is not viable, we researched whether any existing tools already solve this problem:</p>

                <div class="table-container">
                    <table>
                        <thead><tr><th>Tool</th><th>Mocks RFC Binary?</th><th>Free?</th><th>Verdict</th></tr></thead>
                        <tbody>
                            <tr><td><strong>Broadcom DevTest</strong> (CA Service Virtualization)</td><td><span class="status-badge yes">YES</span> &mdash; records/replays JCo RFC &amp; IDoc traffic</td><td><span class="status-badge no">NO</span> &mdash; expensive enterprise license</td><td>The <strong>only</strong> tool that can mock binary RFC. But cost-prohibitive.</td></tr>
                            <tr><td><strong>WireMock / Mockoon / Hoverfly</strong></td><td><span class="status-badge no">NO</span> &mdash; HTTP only</td><td><span class="status-badge yes">YES</span></td><td>Work great for OData snaps, useless for RFC snaps</td></tr>
                            <tr><td><strong>SAP CAP Mock Server</strong></td><td><span class="status-badge no">NO</span> &mdash; OData only</td><td><span class="status-badge yes">YES</span></td><td>SAP's own mock framework, but only for OData/HTTP</td></tr>
                            <tr><td><strong>SAP FE MockServer</strong> (open-ux-odata)</td><td><span class="status-badge no">NO</span> &mdash; OData only</td><td><span class="status-badge yes">YES</span></td><td>OData V2/V4 with stateful CRUD, but no RFC</td></tr>
                            <tr><td><strong>SAP Business Accelerator Hub</strong></td><td><span class="status-badge no">NO</span> &mdash; OData sandbox, read-only</td><td><span class="status-badge yes">YES</span></td><td>Free sandbox APIs, but read-only and no RFC</td></tr>
                            <tr><td><strong>Mountebank</strong></td><td><span class="status-badge partial">TCP mode</span> &mdash; but you'd still need to parse binary</td><td><span class="status-badge yes">YES</span></td><td>Has TCP protocol support but same binary parsing problem</td></tr>
                            <tr><td><strong>Traffic Parrot / Specmatic / Microcks</strong></td><td><span class="status-badge no">NO</span></td><td>Varies</td><td>HTTP/gRPC only</td></tr>
                        </tbody>
                    </table>
                </div>

                <div class="info-box" style="background:#f5f5f5; border-left-color:#95a5a6;">
                    <strong>Conclusion:</strong> No free, open-source tool exists that can mock SAP's binary RFC protocol. The only commercial option (Broadcom DevTest) is cost-prohibitive. This confirms that for RFC-level SAP snaps, you need a different approach entirely &mdash; either mock at the SnapLogic layer (Option 1) or intercept inside the snap before binary encoding (Option 3 below).
                </div>

                <h3>For SAP OData Snaps &mdash; Plenty of Options</h3>

                <p>If your pipelines use the <strong>SAP S/4HANA Snap Pack</strong> (OData over HTTP), there are many free tools that work today:</p>

                <div class="table-container">
                    <table>
                        <thead><tr><th>Tool</th><th>Stateful CRUD?</th><th>Best For</th></tr></thead>
                        <tbody>
                            <tr><td><strong>Our Django Mock Server</strong></td><td><span class="status-badge yes">YES</span></td><td>Already built, fits our stack, same pattern as Salesforce mock</td></tr>
                            <tr><td><strong>SAP CAP Mock Server</strong> (Node.js)</td><td><span class="status-badge yes">YES</span></td><td>SAP's own framework, imports EDMX definitions directly</td></tr>
                            <tr><td><strong>SAP FE MockServer</strong> (npm)</td><td><span class="status-badge yes">YES</span></td><td>OData V2/V4, works with Express.js, 33K weekly downloads</td></tr>
                            <tr><td><strong>WireMock</strong></td><td><span class="status-badge partial">Limited</span></td><td>General HTTP mock, proven with SAP Cloud SDK</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Option 4: JCo Server -->
            <div class="data-section">
                <h2>Option 4: JCo Server (Java) <span class="badge blue">Alternative</span></h2>

                <p>SAP JCo has a built-in <strong>Server mode</strong> &mdash; a Java program that registers as an RFC destination and responds to incoming calls.</p>

                <div class="code-block">
<span class="url-host">SnapLogic Pipeline</span>                           <span class="url-host">JCo Mock Server</span>

<span class="dim">+----------------+</span>     <span class="variable">RFC Protocol</span>          <span class="dim">+---------------------+</span>
<span class="dim">|</span>  SAP IDoc      <span class="dim">|</span>  <span class="arrow">══════════════════►</span>  <span class="dim">|</span>  Java JCo Server   <span class="dim">|</span>
<span class="dim">|</span>  Read Snap     <span class="dim">|</span>     Port 33xx            <span class="dim">|</span>  (mock RFC          <span class="dim">|</span>
<span class="dim">|</span>                <span class="dim">|</span>     Proprietary binary   <span class="dim">|</span>   listener)         <span class="dim">|</span>
<span class="dim">+----------------+</span>                           <span class="dim">+---------------------+</span></div>

                <div class="table-container">
                    <table>
                        <thead><tr><th>Pros</th><th>Cons</th></tr></thead>
                        <tbody>
                            <tr><td style="color:#27ae60;">Official SAP library &mdash; most stable</td><td>Java, not Python (different from our stack)</td></tr>
                            <tr><td style="color:#27ae60;">Best documentation for server mode</td><td>JCo is licensed and not freely redistributable</td></tr>
                            <tr><td style="color:#27ae60;">Most mature option for RFC mocking</td><td>Need to define function metadata programmatically</td></tr>
                            <tr><td style="color:#27ae60;">Used in production SAP integrations</td><td>Heavier Docker image (JVM + JCo native libs)</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Option 5: WebSocket RFC -->
            <div class="data-section">
                <h2>Option 5: WebSocket RFC (Future) <span class="badge purple">Experimental</span></h2>

                <p>SAP has introduced <strong>WebSocket RFC</strong> &mdash; RFC calls tunneled over HTTP/WebSocket. If SnapLogic snaps support WebSocket RFC, we could potentially mock with a Python WebSocket server.</p>

                <div class="code-block">
<span class="url-host">SnapLogic Pipeline</span>                           <span class="match">WebSocket Mock Server</span>

<span class="dim">+----------------+</span>     <span class="success">WebSocket (HTTP!)</span>     <span class="dim">+---------------------+</span>
<span class="dim">|</span>  SAP Snap      <span class="dim">|</span>  <span class="arrow">══════════════════►</span>  <span class="dim">|</span>  Python WebSocket  <span class="dim">|</span>
<span class="dim">|</span>                <span class="dim">|</span>     Port 443 (HTTPS)    <span class="dim">|</span>  Server (mock)     <span class="dim">|</span>
<span class="dim">|</span>                <span class="dim">|</span>     Standard HTTP       <span class="dim">|</span>                     <span class="dim">|</span>
<span class="dim">+----------------+</span>                           <span class="dim">+---------------------+</span></div>

                <div class="table-container">
                    <table>
                        <thead><tr><th>Pros</th><th>Cons</th></tr></thead>
                        <tbody>
                            <tr><td style="color:#27ae60;">HTTP-based! No SAP native libraries needed</td><td>Very new &mdash; SnapLogic may not support it yet</td></tr>
                            <tr><td style="color:#27ae60;">Could integrate with Django/Python</td><td>Limited documentation</td></tr>
                            <tr><td style="color:#27ae60;">Firewall friendly (standard ports)</td><td>Need to reverse-engineer the WebSocket RFC framing</td></tr>
                        </tbody>
                    </table>
                </div>

                <div class="info-box purple">
                    <strong>Verdict:</strong> Unlikely to work today, but worth watching for the future as SAP modernizes.
                </div>
            </div>

            <!-- Option 6: Snap Mock Mode -->
            <div class="data-section">
                <h2>Option 6: Snap Mock Mode (Intercept Inside the Snap) <span class="badge" style="background:#8e24aa;">Requires Snap Team</span></h2>

                <p>Instead of mocking the server at the other end of the network, <strong>change the snap code itself</strong> to run in a "mock mode." When the snap is in mock mode, it intercepts the data <strong>before</strong> it gets serialized to binary RFC and redirects it to something we can talk to (HTTP/JMS/in-process).</p>

                <div class="info-box" style="background:#f3e5f5; border-left-color:#8e24aa;">
                    <strong>Key insight:</strong> With all our other mocks (Salesforce, NetSuite, etc.), the snap is unchanged &mdash; it reaches across the network normally, and we just replace what's at the other end. With SAP RFC snaps, you <strong>can't</strong> replace what's at the other end (proprietary binary). So instead, you modify the snap itself to create an alternate path.
                </div>

                <h3>How It Works</h3>

                <div class="code-block">
<span class="label">NORMAL MODE (production):</span>
<span class="dim">─────────────────────────────────────────────────────────────────</span>
  SAP IDoc Snap
       <span class="dim">|</span>
       <span class="dim">v</span>  Internal: builds XML representation of RFC call
       <span class="dim">|</span>
       <span class="dim">v</span>  JCo serializes XML → <span class="danger">proprietary binary</span>
       <span class="dim">|</span>
       <span class="dim">v</span>  Sends binary over TCP port 3300
       <span class="dim">|</span>
       <span class="dim">v</span>
    <span class="dim">Real SAP System</span>


<span class="label">MOCK MODE (testing):</span>
<span class="dim">─────────────────────────────────────────────────────────────────</span>
  SAP IDoc Snap  <span class="match">(running with MOCK_MODE=true)</span>
       <span class="dim">|</span>
       <span class="dim">v</span>  Internal: builds XML representation of RFC call
       <span class="dim">|</span>
       <span class="dim">v</span>  <span class="success">INTERCEPT HERE! XML is clean, structured, readable</span>
       <span class="dim">|</span>
       <span class="dim">v</span>  Instead of JCo binary serialization,
       <span class="dim">|</span>  redirect the XML to an HTTP endpoint
       <span class="dim">v</span>
    <span class="match">Django Mock Server (port 8080)</span>  ← <span class="success">We know how to build this!</span>
       <span class="dim">|</span>
       <span class="dim">v</span>  Django receives XML, does CRUD on in-memory database,
       <span class="dim">|</span>  returns XML response
       <span class="dim">v</span>
    Snap receives response as if from SAP</div>

                <h3>Why This Works</h3>

                <p>Right before the data hits the network and gets serialized to binary, <strong>everything is clean, structured XML</strong>. The XML contains the function name, all parameters, and all data in a readable format. If the snap can be modified to redirect this XML to an HTTP endpoint instead of the JCo binary path, then the entire problem reduces to <strong>HTTP/XML mocking &mdash; which we already know how to do with Django</strong>.</p>

                <div class="code-block">
<span class="label">The XML representation (what exists INSIDE the snap before binary):</span>
<span class="dim">─────────────────────────────────────────────────────────────────</span>

<span class="string">&lt;RFC name="IDOC_INBOUND_ASYNCHRONOUS"&gt;</span>
  <span class="string">&lt;IMPORTING&gt;</span>
    <span class="string">&lt;IDOC_CONTROL_REC_40&gt;</span>
      <span class="string">&lt;DOCNUM&gt;</span>0000000012345<span class="string">&lt;/DOCNUM&gt;</span>
      <span class="string">&lt;IDOCTP&gt;</span>ORDERS05<span class="string">&lt;/IDOCTP&gt;</span>
      <span class="string">&lt;MESTYP&gt;</span>ORDERS<span class="string">&lt;/MESTYP&gt;</span>
    <span class="string">&lt;/IDOC_CONTROL_REC_40&gt;</span>
  <span class="string">&lt;/IMPORTING&gt;</span>
  <span class="string">&lt;TABLES&gt;</span>
    <span class="string">&lt;IDOC_DATA_REC_40&gt;</span>
      <span class="string">&lt;item&gt;</span>
        <span class="string">&lt;SEGNAM&gt;</span>E1EDK01<span class="string">&lt;/SEGNAM&gt;</span>
        <span class="string">&lt;SDATA&gt;</span>...<span class="string">&lt;/SDATA&gt;</span>
      <span class="string">&lt;/item&gt;</span>
    <span class="string">&lt;/IDOC_DATA_REC_40&gt;</span>
  <span class="string">&lt;/TABLES&gt;</span>
<span class="string">&lt;/RFC&gt;</span>

<span class="success">This is readable! This is mockable! This is what Django can handle!</span></div>

                <h3>What Needs to Happen</h3>

                <div class="flow-step">
                    <div class="flow-number">1</div>
                    <div class="flow-content">
                        <h4>Snaps team adds "mock mode" to SAP snaps</h4>
                        <p>A configuration flag (e.g., <code>MOCK_MODE=true</code> or an account property) that tells the snap to redirect RFC calls to an HTTP endpoint instead of the JCo binary path.</p>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number blue">2</div>
                    <div class="flow-content">
                        <h4>Snap sends XML to Django mock server</h4>
                        <p>Instead of <code>JCoFunction.execute(destination)</code>, the snap serializes the function call as XML/JSON and POSTs it to <code>http://mock-server:8080/rfc/IDOC_INBOUND_ASYNCHRONOUS</code>.</p>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number purple">3</div>
                    <div class="flow-content">
                        <h4>Django mock server handles it like any other mock</h4>
                        <p>The Django server receives the XML/JSON, routes it to a CRUD handler, stores data in the in-memory database, and returns a response. Same pattern as Salesforce mock &mdash; just different input format (XML instead of JSON).</p>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number" style="background:#e74c3c;">4</div>
                    <div class="flow-content">
                        <h4>Robot Framework tests work the same way</h4>
                        <p>Tests trigger pipelines, pipelines talk to Django mock, tests validate via admin API. Identical workflow to Salesforce mock testing.</p>
                    </div>
                </div>

                <h3>GroundPlex / JCC Consideration</h3>

                <p>The GroundPlex JCC (Java Container Controller) already has a <strong>built-in web server</strong>. In mock mode, Robot Framework could potentially talk to this built-in endpoint to inspect mocked data, without needing a separate Django container. This is worth exploring with the Snaps team.</p>

                <div class="table-container">
                    <table>
                        <thead><tr><th>Pros</th><th>Cons</th></tr></thead>
                        <tbody>
                            <tr><td style="color:#27ae60;">Solves the binary protocol problem completely &mdash; intercepts before binary</td><td><strong>Requires Snaps team to modify snap code</strong></td></tr>
                            <tr><td style="color:#27ae60;">Mock server side is pure Django/HTTP &mdash; same pattern as Salesforce</td><td>Need buy-in from Snaps team (historically resistant)</td></tr>
                            <tr><td style="color:#27ae60;">XML data is clean, readable, structured &mdash; easy to parse</td><td>Mock mode code must be maintained alongside production snap code</td></tr>
                            <tr><td style="color:#27ae60;">Can prove what the snap "put on the wire" without leaving the network</td><td>Only works for SnapLogic &mdash; not reusable for other SAP clients</td></tr>
                            <tr><td style="color:#27ae60;">Could work for ANY snap, not just SAP (general mock mode pattern)</td><td>Requires coordination between QA and Snaps engineering teams</td></tr>
                            <tr><td style="color:#27ae60;">No SAP infrastructure needed at all</td><td>&mdash;</td></tr>
                        </tbody>
                    </table>
                </div>

                <div class="info-box" style="background:#f3e5f5; border-left-color:#8e24aa;">
                    <strong>Why this is powerful:</strong> If the Snaps team adds mock mode to SAP snaps, the same pattern can be applied to <strong>every snap in SnapLogic</strong>. Every snap is just making an API call behind the scenes. Mock mode redirects that call to a Django endpoint. One pattern to mock them all. This is the long-term vision &mdash; a coding-agent-assisted approach where we can build mocks for any snap rapidly.
                </div>
            </div>

            <!-- Option 7: Hybrid -->
            <div class="data-section">
                <h2>Option 7: PyRFC + Django Hybrid (Unified Mock Service) <span class="badge">Advanced</span></h2>

                <p>Combine PyRFC (for RFC protocol) with the existing Django mock server in a <strong>single container</strong> with shared in-memory state:</p>

                <div class="code-block">
<span class="dim">+--------------------------------------------------------------+</span>
<span class="dim">|</span>              <span class="match">SLIM Mock Service (single container)</span>               <span class="dim">|</span>
<span class="dim">|</span>                                                              <span class="dim">|</span>
<span class="dim">|</span>  <span class="url-host">SnapLogic SAP IDoc Snap</span>                                     <span class="dim">|</span>
<span class="dim">|</span>       <span class="dim">|</span>  RFC Protocol                                          <span class="dim">|</span>
<span class="dim">|</span>       <span class="dim">v</span>  (port 33xx)                                          <span class="dim">|</span>
<span class="dim">|</span>  <span class="dim">+-------------------------+</span>                                 <span class="dim">|</span>
<span class="dim">|</span>  <span class="dim">|</span> <span class="warn">PyRFC Server Thread</span>    <span class="dim">|</span>                                 <span class="dim">|</span>
<span class="dim">|</span>  <span class="dim">|</span> (RFC listener)          <span class="dim">|</span>                                 <span class="dim">|</span>
<span class="dim">|</span>  <span class="dim">+-----------+-------------+</span>                                 <span class="dim">|</span>
<span class="dim">|</span>              <span class="dim">|</span>                                                    <span class="dim">|</span>
<span class="dim">|</span>              <span class="dim">v</span>                                                    <span class="dim">|</span>
<span class="dim">|</span>  <span class="dim">+------------------------------------------+</span>               <span class="dim">|</span>
<span class="dim">|</span>  <span class="dim">|</span>  <span class="match">Shared In-Memory Database</span>               <span class="dim">|</span>               <span class="dim">|</span>
<span class="dim">|</span>  <span class="dim">|</span>  database = { 'Account': {...},           <span class="dim">|</span>               <span class="dim">|</span>
<span class="dim">|</span>  <span class="dim">|</span>               'IDoc': {...},              <span class="dim">|</span>               <span class="dim">|</span>
<span class="dim">|</span>  <span class="dim">|</span>               'SalesOrder': {...} }       <span class="dim">|</span>               <span class="dim">|</span>
<span class="dim">|</span>  <span class="dim">+------------------------------------------+</span>               <span class="dim">|</span>
<span class="dim">|</span>              <span class="dim">^</span>                                                    <span class="dim">|</span>
<span class="dim">|</span>              <span class="dim">|</span>                                                    <span class="dim">|</span>
<span class="dim">|</span>  <span class="dim">+-----------+-------------+</span>                                 <span class="dim">|</span>
<span class="dim">|</span>  <span class="dim">|</span> <span class="success">Django Server Thread</span>   <span class="dim">|</span>                                 <span class="dim">|</span>
<span class="dim">|</span>  <span class="dim">|</span> (HTTP/HTTPS listener)   <span class="dim">|</span>                                 <span class="dim">|</span>
<span class="dim">|</span>  <span class="dim">+-------------------------+</span>                                 <span class="dim">|</span>
<span class="dim">|</span>       <span class="dim">^</span>  HTTP/HTTPS                                          <span class="dim">|</span>
<span class="dim">|</span>       <span class="dim">|</span>  (port 8443)                                          <span class="dim">|</span>
<span class="dim">|</span>  <span class="url-host">SnapLogic Salesforce / SAP OData Snaps</span>                      <span class="dim">|</span>
<span class="dim">|</span>                                                              <span class="dim">|</span>
<span class="dim">+--------------------------------------------------------------+</span></div>

                <p>Both the PyRFC server and Django server run in the <strong>same process</strong>, sharing the same in-memory database &mdash; just like the current HTTP+HTTPS dual-protocol architecture!</p>

                <div class="code-label">run_server.py (extended concept)</div>
                <div class="code-block">
<span class="keyword">import</span> threading
<span class="keyword">from</span> django_app <span class="keyword">import</span> get_wsgi_application
<span class="keyword">from</span> pyrfc_mock <span class="keyword">import</span> start_rfc_server

<span class="comment"># Shared in-memory database (same dict for both protocols)</span>
database = {}

<span class="comment"># Thread 1: Django HTTP/HTTPS (Salesforce, SAP OData)</span>
django_thread = threading.Thread(
    target=start_django_server, args=(database,))
django_thread.start()

<span class="comment"># Thread 2: PyRFC server (SAP IDoc/BAPI)</span>
rfc_thread = threading.Thread(
    target=start_rfc_server, args=(database,))
rfc_thread.start()

<span class="comment"># Both threads share the same 'database' dict!</span>
<span class="comment"># A record created via Salesforce REST can be read via SAP RFC</span></div>

                <div class="table-container">
                    <table>
                        <thead><tr><th>Pros</th><th>Cons</th></tr></thead>
                        <tbody>
                            <tr><td style="color:#27ae60;">Single container for ALL mocks (Salesforce + SAP + OData)</td><td>Requires SAP NW RFC SDK in Docker image</td></tr>
                            <tr><td style="color:#27ae60;">Shared state between RFC and HTTP mocks</td><td>More complex architecture</td></tr>
                            <tr><td style="color:#27ae60;">Fits plugin architecture perfectly</td><td>Native C library in Docker image increases size</td></tr>
                            <tr><td style="color:#27ae60;">Python throughout &mdash; consistent stack</td><td>PyRFC server mode needs thorough testing</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Summary & Recommendation -->
            <div class="data-section">
                <h2>RFC Mocking: Comparison &amp; Recommendation <span class="badge">Summary</span></h2>

                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Priority</th>
                                <th>Approach</th>
                                <th>Language</th>
                                <th>Effort</th>
                                <th>Value</th>
                                <th>Works Today?</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr style="background:#f0fff0;">
                                <td><strong>★</strong></td>
                                <td><strong>Mock at SnapLogic Layer</strong> (Option 1)</td>
                                <td>SnapLogic</td>
                                <td style="color:#27ae60; font-weight:bold;">Very Low</td>
                                <td>90% of testing value, 10% of effort</td>
                                <td><span class="status-badge yes">YES</span></td>
                            </tr>
                            <tr>
                                <td><strong>2</strong></td>
                                <td><strong>PyRFC Smart Mock</strong> (Option 2)</td>
                                <td>Python</td>
                                <td style="color:#e67e22; font-weight:bold;">Medium</td>
                                <td>Stateful CRUD mock, same as Salesforce pattern</td>
                                <td><span class="status-badge partial">Needs SDK + Gateway</span></td>
                            </tr>
                            <tr style="background:#fff0f0;">
                                <td><s>3</s></td>
                                <td><s><strong>Raw TCP RFC Mock</strong> (Option 3)</s></td>
                                <td>Python</td>
                                <td style="color:#95a5a6; font-weight:bold;">N/A</td>
                                <td style="color:#95a5a6;">Not viable &mdash; can't reverse-engineer proprietary binary</td>
                                <td><span class="status-badge no">NOT VIABLE</span></td>
                            </tr>
                            <tr>
                                <td><strong>4</strong></td>
                                <td><strong>JCo Server</strong> (Option 4)</td>
                                <td>Java</td>
                                <td style="color:#e74c3c; font-weight:bold;">High</td>
                                <td>Most stable but different language</td>
                                <td><span class="status-badge partial">Needs JCo + Gateway</span></td>
                            </tr>
                            <tr>
                                <td><strong>5</strong></td>
                                <td><strong>WebSocket RFC</strong> (Option 5)</td>
                                <td>Python</td>
                                <td style="color:#e74c3c; font-weight:bold;">Unknown</td>
                                <td>Future possibility</td>
                                <td><span class="status-badge no">NO</span></td>
                            </tr>
                            <tr style="background:#f3e5f5;">
                                <td><strong>6</strong></td>
                                <td><strong>Snap Mock Mode</strong> (Option 6)</td>
                                <td>Java + Python</td>
                                <td style="color:#e67e22; font-weight:bold;">Medium</td>
                                <td>Intercept inside snap before binary &mdash; mock with Django</td>
                                <td><span class="status-badge partial">Needs Snaps Team</span></td>
                            </tr>
                            <tr>
                                <td><strong>7</strong></td>
                                <td><strong>PyRFC + Django Hybrid</strong> (Option 7)</td>
                                <td>Python</td>
                                <td style="color:#e67e22; font-weight:bold;">Medium-High</td>
                                <td>Unified mock service for everything</td>
                                <td><span class="status-badge partial">Needs SDK + Gateway</span></td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="info-box">
                    <strong>Practical next steps:</strong><br>
                    <strong>1. Right now:</strong> Use <strong>Option 1 (Mock at SnapLogic Layer)</strong> &mdash; capture real IDoc responses as JSON, or bypass the SAP snap with a JSON Generator/Parser. Zero setup, works immediately. This gives you 90% of testing value.<br>
                    <strong>2. Long-term (best approach):</strong> Push for <strong>Option 6 (Snap Mock Mode)</strong> &mdash; Snaps team adds mock mode to SAP snaps, intercepting at the XML layer before binary encoding. Django mock server handles the rest. This pattern can extend to <strong>every snap in SnapLogic</strong>.<br>
                    <strong>3. For OData snaps:</strong> Multiple free tools exist today &mdash; our Django mock, SAP CAP Mock Server, SAP FE MockServer, WireMock. OData is HTTP-based, so <strong>no special handling needed</strong>.<br>
                    <strong>4. Not viable:</strong> <s>Option 3 (Raw TCP)</s> &mdash; RFC binary is proprietary and cannot be reverse-engineered. Options 2, 4, and 7 all require SAP Gateway infrastructure. The only commercial tool for RFC mocking (Broadcom DevTest) is cost-prohibitive.
                </div>
            </div>
        </div>

        <!-- ═══════════════════════════════════════════════════════════════
             TAB 6: SNAPLOGIC SAP SNAPS
             ═══════════════════════════════════════════════════════════════ -->
        <div id="snaplogic-snaps" class="tab-content">
            <div class="data-section">
                <h2>SnapLogic SAP Snap Packs <span class="badge">Snap Reference</span></h2>

                <p>SnapLogic has <strong>multiple SAP Snap Packs</strong> that use <strong>different protocols</strong>. This determines which ones we can mock:</p>

                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>Snap Pack</th><th>Snaps Included</th><th>Protocol</th><th>Mock with Django?</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>SAP Snap Pack</strong></td>
                                <td>IDoc Read, IDoc Write, BAPI Execute</td>
                                <td><span class="method rfc">RFC</span> via JCo (proprietary binary)</td>
                                <td><span class="status-badge no">NO</span></td>
                            </tr>
                            <tr>
                                <td><strong>SAP S/4HANA Snap Pack</strong></td>
                                <td>Read, Create, Update, Delete, Search</td>
                                <td><span class="method get">OData</span> over HTTP/HTTPS</td>
                                <td><span class="status-badge yes">YES</span></td>
                            </tr>
                            <tr>
                                <td><strong>SAP S/4HANA Cloud Snap Pack</strong></td>
                                <td>Read, Create, Update, Delete</td>
                                <td><span class="method get">OData</span> over HTTP/HTTPS</td>
                                <td><span class="status-badge yes">YES</span></td>
                            </tr>
                            <tr>
                                <td><strong>SAP Ariba Snap Pack</strong></td>
                                <td>Read, Write</td>
                                <td><span class="method get">REST</span> over HTTP/HTTPS</td>
                                <td><span class="status-badge yes">YES</span></td>
                            </tr>
                            <tr>
                                <td><strong>SAP Concur Snap Pack</strong></td>
                                <td>Read, Write</td>
                                <td><span class="method get">REST</span> over HTTP/HTTPS</td>
                                <td><span class="status-badge yes">YES</span></td>
                            </tr>
                            <tr>
                                <td><strong>SAP SuccessFactors Snap Pack</strong></td>
                                <td>Read, Write, Upsert</td>
                                <td><span class="method get">OData</span> over HTTP/HTTPS</td>
                                <td><span class="status-badge yes">YES</span></td>
                            </tr>
                            <tr>
                                <td><strong>SAP HANA Snap Pack</strong></td>
                                <td>Select, Insert, Update, Execute</td>
                                <td>JDBC (database protocol)</td>
                                <td><span class="status-badge no">NO</span> (need real DB)</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="info-box blue">
                    <strong>Good news:</strong> The majority of modern SAP integrations use <strong>OData over HTTP</strong> (S/4HANA snaps). Only the legacy SAP IDoc/BAPI snaps use the proprietary RFC protocol.
                </div>

                <h3>SAP IDoc Read Snap Settings (From Your Screenshot)</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>Field</th><th>Value</th><th>What It Means</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Label</strong></td>
                                <td><code>SAP IDoc Read</code></td>
                                <td>Snap display name</td>
                            </tr>
                            <tr>
                                <td><strong>IDoc Read BAPI Name</strong></td>
                                <td><code>Z_SNAP_IDOC_READ_COMPLETELY</code></td>
                                <td>Custom RFC function to call (the <code>Z_</code> means custom-built)</td>
                            </tr>
                            <tr>
                                <td><strong>Max request attempts</strong></td>
                                <td><code>3</code></td>
                                <td>How many times to retry on failure</td>
                            </tr>
                            <tr>
                                <td><strong>Request retry interval</strong></td>
                                <td><code>5</code></td>
                                <td>Seconds between retries</td>
                            </tr>
                            <tr>
                                <td><strong>Snap execution</strong></td>
                                <td><code>Validate &amp; Execute</code></td>
                                <td>Standard execution mode</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- ═══════════════════════════════════════════════════════════════
             TAB 7: ODATA URL PATTERNS
             ═══════════════════════════════════════════════════════════════ -->
        <div id="odata-urls" class="tab-content">
            <div class="data-section">
                <h2>SAP S/4HANA OData URL Patterns <span class="badge blue">Mockable!</span></h2>

                <p>SAP S/4HANA uses standard <strong>OData REST APIs over HTTP</strong> &mdash; just like Salesforce uses REST. This is what we CAN mock with Django!</p>

                <div class="info-box">
                    <strong>OData</strong> is an open standard for REST APIs. SAP uses it extensively in S/4HANA. The URL patterns look similar to Salesforce, just with different path structures.
                </div>

                <h3>OData URL Structure</h3>
                <div class="code-block">
<span class="comment">SAP S/4HANA OData URL:</span>
https://<span class="url-host">sap-server:443</span><span class="url-fixed">/sap/opu/odata/sap/</span><span class="url-dynamic">API_BUSINESS_PARTNER</span><span class="url-fixed">/</span><span class="url-dynamic">A_BusinessPartner</span>
<span class="dim">|___________________|</span><span class="dim">|__________________|</span><span class="dim">|_____________________|</span><span class="dim">|___________________|</span>
     <span class="url-host">Hostname</span>          <span class="url-fixed">OData base path</span>     <span class="url-dynamic">Service Name</span>          <span class="url-dynamic">Entity Set</span>
  <span class="comment">(we replace)</span>          <span class="comment">(fixed)</span>            <span class="comment">(dynamic)</span>             <span class="comment">(dynamic)</span>


<span class="comment">Mock Server URL:</span>
https://<span class="match">sap-mock:8443</span><span class="url-fixed">/sap/opu/odata/sap/</span><span class="url-dynamic">API_BUSINESS_PARTNER</span><span class="url-fixed">/</span><span class="url-dynamic">A_BusinessPartner</span>
<span class="dim">|___________________|</span>
  <span class="match">Only this changes!</span></div>

                <h3>Common SAP S/4HANA OData Endpoints</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>Method</th><th>URL Pattern</th><th>Description</th><th>Django Pattern</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><span class="method get">GET</span></td>
                                <td><code>/sap/opu/odata/sap/{Service}/{EntitySet}</code></td>
                                <td>List entities</td>
                                <td><code>&lt;str:service&gt;/&lt;str:entity_set&gt;</code></td>
                            </tr>
                            <tr>
                                <td><span class="method get">GET</span></td>
                                <td><code>/sap/opu/odata/sap/{Service}/{EntitySet}('{Key}')</code></td>
                                <td>Read single entity</td>
                                <td><code>&lt;str:service&gt;/&lt;str:entity_set&gt;(&lt;key&gt;)</code></td>
                            </tr>
                            <tr>
                                <td><span class="method post">POST</span></td>
                                <td><code>/sap/opu/odata/sap/{Service}/{EntitySet}</code></td>
                                <td>Create entity</td>
                                <td><code>&lt;str:service&gt;/&lt;str:entity_set&gt;</code></td>
                            </tr>
                            <tr>
                                <td><span class="method patch">PATCH</span></td>
                                <td><code>/sap/opu/odata/sap/{Service}/{EntitySet}('{Key}')</code></td>
                                <td>Update entity</td>
                                <td><code>&lt;str:service&gt;/&lt;str:entity_set&gt;(&lt;key&gt;)</code></td>
                            </tr>
                            <tr>
                                <td><span class="method delete">DELETE</span></td>
                                <td><code>/sap/opu/odata/sap/{Service}/{EntitySet}('{Key}')</code></td>
                                <td>Delete entity</td>
                                <td><code>&lt;str:service&gt;/&lt;str:entity_set&gt;(&lt;key&gt;)</code></td>
                            </tr>
                            <tr>
                                <td><span class="method get">GET</span></td>
                                <td><code>/sap/opu/odata/sap/{Service}/$metadata</code></td>
                                <td>Get OData schema (XML)</td>
                                <td><code>&lt;str:service&gt;/$metadata</code></td>
                            </tr>
                            <tr>
                                <td><span class="method get">GET</span></td>
                                <td><code>.../{EntitySet}?$filter=Field eq 'Value'</code></td>
                                <td>Filtered query</td>
                                <td>Query string parameter</td>
                            </tr>
                            <tr>
                                <td><span class="method get">GET</span></td>
                                <td><code>.../{EntitySet}?$select=Field1,Field2</code></td>
                                <td>Select specific fields</td>
                                <td>Query string parameter</td>
                            </tr>
                            <tr>
                                <td><span class="method get">GET</span></td>
                                <td><code>.../{EntitySet}?$top=10&amp;$skip=20</code></td>
                                <td>Pagination</td>
                                <td>Query string parameter</td>
                            </tr>
                            <tr>
                                <td><span class="method get">GET</span></td>
                                <td><code>.../{EntitySet}?$expand=NavProperty</code></td>
                                <td>Expand related entities</td>
                                <td>Query string parameter</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Example: Business Partner API</h3>
                <div class="code-label blue">List all business partners</div>
                <div class="code-block">
<span class="method get">GET</span> /sap/opu/odata/sap/API_BUSINESS_PARTNER/A_BusinessPartner
    ?$select=BusinessPartner,BusinessPartnerName,Industry
    &$filter=Industry eq 'MANU'
    &$top=10

<span class="comment">Response (JSON):</span>
{
  <span class="string">"d"</span>: {
    <span class="string">"results"</span>: [
      {
        <span class="string">"BusinessPartner"</span>: <span class="string">"1000001"</span>,
        <span class="string">"BusinessPartnerName"</span>: <span class="string">"Acme Corp"</span>,
        <span class="string">"Industry"</span>: <span class="string">"MANU"</span>
      },
      {
        <span class="string">"BusinessPartner"</span>: <span class="string">"1000002"</span>,
        <span class="string">"BusinessPartnerName"</span>: <span class="string">"Global Industries"</span>,
        <span class="string">"Industry"</span>: <span class="string">"MANU"</span>
      }
    ]
  }
}</div>

                <h3>Common SAP S/4HANA OData Services</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>Service Name</th><th>Entity Sets</th><th>Business Area</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>API_BUSINESS_PARTNER</code></td>
                                <td>A_BusinessPartner, A_BusinessPartnerAddress</td>
                                <td>Customers / Vendors</td>
                            </tr>
                            <tr>
                                <td><code>API_SALES_ORDER_SRV</code></td>
                                <td>A_SalesOrder, A_SalesOrderItem</td>
                                <td>Sales Orders</td>
                            </tr>
                            <tr>
                                <td><code>API_PURCHASEORDER_PROCESS_SRV</code></td>
                                <td>A_PurchaseOrder, A_PurchaseOrderItem</td>
                                <td>Purchase Orders</td>
                            </tr>
                            <tr>
                                <td><code>API_MATERIAL_STOCK_SRV</code></td>
                                <td>A_MatlStkInAcctMod</td>
                                <td>Material Inventory</td>
                            </tr>
                            <tr>
                                <td><code>API_PRODUCT_SRV</code></td>
                                <td>A_Product, A_ProductDescription</td>
                                <td>Product Master</td>
                            </tr>
                            <tr>
                                <td><code>API_BILLING_DOCUMENT_SRV</code></td>
                                <td>A_BillingDocument, A_BillingDocumentItem</td>
                                <td>Invoices / Billing</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>OData vs Salesforce REST Side-by-Side</h3>
                <div class="comparison">
                    <div class="comparison-col real">
                        <h4>Salesforce REST</h4>
                        <p style="font-size:11px; font-family:monospace; margin:0;">
                            GET /services/data/v58.0/sobjects/<strong>Account</strong><br>
                            GET /services/data/v58.0/query?<strong>q=SELECT...</strong><br>
                            Response: {"records": [...]}
                        </p>
                    </div>
                    <div class="comparison-col mock">
                        <h4>SAP S/4HANA OData</h4>
                        <p style="font-size:11px; font-family:monospace; margin:0;">
                            GET /sap/opu/odata/sap/SERVICE/<strong>EntitySet</strong><br>
                            GET .../EntitySet?<strong>$filter=Field eq 'X'</strong><br>
                            Response: {"d": {"results": [...]}}
                        </p>
                    </div>
                </div>

                <div class="info-box">
                    <strong>Very similar patterns!</strong> Both use HTTP REST, both return JSON, both support filtering and pagination. The main differences are the base path structure and that OData wraps results in <code>{"d": {"results": [...]}}</code> instead of <code>{"records": [...]}</code>.
                </div>
            </div>
        </div>

        <!-- ═══════════════════════════════════════════════════════════════
             TAB 8: MOCK STRATEGY
             ═══════════════════════════════════════════════════════════════ -->
        <div id="mock-strategy" class="tab-content">
            <div class="data-section">
                <h2>SAP Mock Strategy <span class="badge">Roadmap</span></h2>

                <div class="info-box orange">
                    <strong>Guiding principle:</strong> "SAP and Salesforce are the big ones. Don't boil the ocean &mdash; mock just enough per pipeline package."
                </div>

                <h3>Recommended Approach</h3>

                <div class="flow-step">
                    <div class="flow-number">1</div>
                    <div class="flow-content">
                        <h4>Start with SAP S/4HANA OData Mock (Django Plugin)</h4>
                        <p>Create a <code>plugins/sap_s4hana/</code> plugin in the mock service. This handles all OData-based SAP snaps (S/4HANA Read, Create, Update, Delete). Same approach as the Salesforce plugin &mdash; just different URL patterns and response format.</p>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number blue">2</div>
                    <div class="flow-content">
                        <h4>Determine Customer's SAP Usage</h4>
                        <p>Analyze customer pipeline data to determine: Do they use S/4HANA OData snaps or legacy IDoc/BAPI snaps? How much of their pipeline work involves SAP? This data will inform priorities.</p>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number purple">3</div>
                    <div class="flow-content">
                        <h4>Discuss IDoc/RFC Mocking with the Team</h4>
                        <p>If the customer heavily uses IDoc/BAPI snaps, discuss options: (a) test with real SAP, (b) build a JCo Server mock in Java, or (c) skip IDoc mocking for now and focus on what Django can handle.</p>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number orange">4</div>
                    <div class="flow-content">
                        <h4>Add to Plugin Architecture</h4>
                        <p>The SAP OData plugin fits perfectly into the SLIM Mock Service plugin architecture: <code>MOCK_PLUGINS=salesforce,sap_s4hana</code></p>
                    </div>
                </div>

                <h3>Plugin Structure for SAP</h3>
                <div class="code-block">
<span class="match">slim-mock-service/</span>
<span class="dim">|</span>
<span class="dim">+--</span> mock_core/                          <span class="comment">&larr; Already built (shared)</span>
<span class="dim">|</span>
<span class="dim">+--</span> plugins/
<span class="dim">|   +--</span> <span class="string">salesforce/</span>                     <span class="comment">&larr; Done! (REST over HTTP)</span>
<span class="dim">|   |</span>
<span class="dim">|   +--</span> <span class="match">sap_s4hana/</span>                     <span class="comment">&larr; NEW plugin (OData over HTTP)</span>
<span class="dim">|       +--</span> __init__.py                  <span class="comment">&larr; registers OData routes</span>
<span class="dim">|       +--</span> views/
<span class="dim">|       |   +--</span> odata_views.py           <span class="comment">&larr; OData CRUD endpoints</span>
<span class="dim">|       |   +--</span> metadata_views.py        <span class="comment">&larr; $metadata endpoint (XML)</span>
<span class="dim">|       |   +--</span> batch_views.py           <span class="comment">&larr; OData $batch processing</span>
<span class="dim">|       |   +--</span> auth_views.py            <span class="comment">&larr; SAP authentication (basic/oauth)</span>
<span class="dim">|       +--</span> parsers/
<span class="dim">|       |   +--</span> odata_filter_parser.py   <span class="comment">&larr; Parse $filter expressions</span>
<span class="dim">|       +--</span> schemas/
<span class="dim">|           +--</span> BusinessPartner.json
<span class="dim">|           +--</span> SalesOrder.json
<span class="dim">|           +--</span> PurchaseOrder.json
<span class="dim">|           +--</span> Material.json</div>

                <h3>What We CAN Mock vs. What We CANNOT</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Snap</th>
                                <th>Protocol</th>
                                <th>Mockable?</th>
                                <th>Plugin</th>
                                <th>Priority</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Salesforce Create/Read/Update/Delete</td>
                                <td>REST/HTTP</td>
                                <td><span class="status-badge yes">YES</span></td>
                                <td><code>salesforce</code></td>
                                <td style="color:#27ae60;">Done!</td>
                            </tr>
                            <tr>
                                <td>Salesforce Bulk API</td>
                                <td>REST/HTTP</td>
                                <td><span class="status-badge yes">YES</span></td>
                                <td><code>salesforce</code></td>
                                <td style="color:#27ae60;">Done!</td>
                            </tr>
                            <tr>
                                <td>SAP S/4HANA Read/Create/Update/Delete</td>
                                <td>OData/HTTP</td>
                                <td><span class="status-badge yes">YES</span></td>
                                <td><code>sap_s4hana</code></td>
                                <td style="color:#2980b9;">Next</td>
                            </tr>
                            <tr>
                                <td>SAP SuccessFactors</td>
                                <td>OData/HTTP</td>
                                <td><span class="status-badge yes">YES</span></td>
                                <td><code>sap_successfactors</code></td>
                                <td style="color:#7f8c8d;">Future</td>
                            </tr>
                            <tr>
                                <td>SAP Ariba / Concur</td>
                                <td>REST/HTTP</td>
                                <td><span class="status-badge yes">YES</span></td>
                                <td><code>sap_ariba</code></td>
                                <td style="color:#7f8c8d;">Future</td>
                            </tr>
                            <tr>
                                <td>SAP IDoc Read/Write</td>
                                <td>RFC (binary)</td>
                                <td><span class="status-badge partial">PyRFC / JCo</span></td>
                                <td><code>sap_rfc</code></td>
                                <td style="color:#e67e22;">PyRFC Server or Pipeline Bypass</td>
                            </tr>
                            <tr>
                                <td>SAP BAPI Execute</td>
                                <td>RFC (binary)</td>
                                <td><span class="status-badge partial">PyRFC / JCo</span></td>
                                <td><code>sap_rfc</code></td>
                                <td style="color:#e67e22;">PyRFC Server or Pipeline Bypass</td>
                            </tr>
                            <tr>
                                <td>SAP HANA DB</td>
                                <td>JDBC</td>
                                <td><span class="status-badge no">NO</span></td>
                                <td>&mdash;</td>
                                <td style="color:#e74c3c;">Use real DB container</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Docker Compose Usage</h3>
                <div class="code-label orange">Control which plugins to load</div>
                <div class="code-block">
<span class="comment"># Salesforce only (current)</span>
<span class="variable">MOCK_PLUGINS</span>=<span class="string">salesforce</span> docker-compose up

<span class="comment"># Salesforce + SAP S/4HANA (next step)</span>
<span class="variable">MOCK_PLUGINS</span>=<span class="string">salesforce,sap_s4hana</span> docker-compose up

<span class="comment"># Full customer setup</span>
<span class="variable">MOCK_PLUGINS</span>=<span class="string">salesforce,sap_s4hana,sap_successfactors</span> docker-compose up</div>

                <h3>Key Discussion Points for the Team</h3>
                <div class="info-box">
                    <strong>1.</strong> Customer SAP usage: Do they use S/4HANA OData snaps or legacy IDoc/BAPI snaps?<br>
                    <strong>2.</strong> OData plugin: Ready to start building &mdash; same Django architecture as Salesforce, different URL patterns.<br>
                    <strong>3.</strong> IDoc/BAPI mocking: <strong>PyRFC Server</strong> (Python) is the recommended approach. Requires SAP NW RFC SDK &mdash; check licensing for dev/test use.<br>
                    <strong>4.</strong> Quick win for IDoc testing: Use <strong>Pipeline Bypass</strong> &mdash; replace SAP snap with JSON Generator containing mock IDoc output.<br>
                    <strong>5.</strong> Long-term: <strong>PyRFC + Django Hybrid</strong> gives a unified mock service for ALL protocols (HTTP + RFC) in one container.
                </div>
            </div>
        </div>

        <!-- ═══════════════════════════════════════════════════════════════
             TAB 11: JCo ↔ PyRFC COMPATIBILITY
             ═══════════════════════════════════════════════════════════════ -->
        <div id="jco-pyrfc" class="tab-content">
            <div class="data-section">
                <h2>PyRFC vs JCo &mdash; Compatibility &amp; Comparison <span class="badge blue">Key Question Answered</span></h2>

                <div class="info-box" style="background:#e8f5e9; border-left-color:#27ae60;">
                    <strong>Question:</strong> SnapLogic's SAP snaps use JCo (Java) internally. Can our PyRFC (Python) mock server still work?<br><br>
                    <strong>Answer: YES!</strong> JCo and PyRFC both speak the <strong>same RFC protocol</strong> over the wire. A JCo client talking to a PyRFC server is no different from a JCo client talking to a real SAP ABAP server.
                </div>

                <h3>Why JCo Client ↔ PyRFC Server Works</h3>
                <p>Both JCo and PyRFC are just <strong>wrappers around the same underlying C library</strong> (SAP NW RFC SDK). They produce <strong>identical binary RFC protocol</strong> on the wire:</p>

                <div class="code-block">
<span class="label">Both libraries wrap the SAME C engine:</span>

  <span class="warn">JCo (Java Connector)</span>                      <span class="success">PyRFC (Python Connector)</span>
  Used by: <span class="variable">SnapLogic</span> (client)                Used by: <span class="variable">Our Mock Server</span> (server)
       <span class="dim">│</span>                                              <span class="dim">│</span>
       <span class="dim">v</span>                                              <span class="dim">v</span>
  <span class="dim">┌──────────────────────┐</span>                    <span class="dim">┌──────────────────────┐</span>
  <span class="dim">│</span> Java Native Interface<span class="dim">│</span>                    <span class="dim">│</span> Python C Extension   <span class="dim">│</span>
  <span class="dim">│</span> (JNI bridge)         <span class="dim">│</span>                    <span class="dim">│</span> (ctypes/cffi bridge) <span class="dim">│</span>
  <span class="dim">└──────────┬───────────┘</span>                    <span class="dim">└──────────┬───────────┘</span>
             <span class="dim">│</span>                                              <span class="dim">│</span>
             <span class="dim">v</span>                                              <span class="dim">v</span>
       <span class="match">┌───────────────────────────────────────────────────┐</span>
       <span class="match">│        SAP NW RFC SDK (C library)                  │</span>
       <span class="match">│        ═══════════════════════════                  │</span>
       <span class="match">│        Same C code. Same binary protocol.           │</span>
       <span class="match">│        Same wire format. Same everything.            │</span>
       <span class="match">└───────────────────────┬───────────────────────────┘</span>
                               <span class="dim">│</span>
                               <span class="dim">v</span>
                    <span class="variable">RFC Binary Protocol over TCP</span>
                    <span class="variable">Port 3300-3399</span>

<span class="success">═══════════════════════════════════════════════════════════</span>
<span class="success">JCo and PyRFC produce IDENTICAL bytes on the wire.</span>
<span class="success">The SAP server (or mock) cannot tell which library sent it.</span>
<span class="success">═══════════════════════════════════════════════════════════</span></div>

                <h3>HTTP Analogy &mdash; Same Concept, Already Proven</h3>
                <p>This is exactly the same as what we already do with Salesforce:</p>

                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th></th><th>Salesforce Mock (working today)</th><th>SAP PyRFC Mock (same concept)</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>SnapLogic uses</strong></td>
                                <td>Java HTTP client (internally)</td>
                                <td>JCo &mdash; Java RFC client (internally)</td>
                            </tr>
                            <tr>
                                <td><strong>Our mock uses</strong></td>
                                <td>Python Django (HTTP server)</td>
                                <td>Python PyRFC (RFC server)</td>
                            </tr>
                            <tr>
                                <td><strong>Protocol on wire</strong></td>
                                <td>HTTP &mdash; same regardless of language</td>
                                <td>RFC &mdash; same regardless of language</td>
                            </tr>
                            <tr>
                                <td><strong>Does it work?</strong></td>
                                <td style="color:#27ae60; font-weight:bold;">YES &mdash; Java client ↔ Python server</td>
                                <td style="color:#27ae60; font-weight:bold;">YES &mdash; Java client ↔ Python server</td>
                            </tr>
                            <tr>
                                <td><strong>Why it works</strong></td>
                                <td>HTTP is HTTP, doesn't matter who sends it</td>
                                <td>RFC is RFC, doesn't matter who sends it</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="info-box" style="background:#e3f2fd; border-left-color:#1976d2;">
                    <strong>Think of it like phone calls:</strong> It doesn't matter if you're calling from an iPhone (JCo/Java) or an Android phone (PyRFC/Python) &mdash; the cellular network protocol is the same. The person on the other end can't tell which phone you used.
                </div>

                <h3>Account Validation &mdash; Step by Step</h3>
                <p>When SnapLogic validates a SAP account, the SAP snap does the following. <strong>PyRFC in server mode handles all of these:</strong></p>

                <div class="code-block">
<span class="label">SnapLogic SAP Account Validation Flow:</span>

  <span class="dim">Step 1:</span> <span class="variable">TCP Connect</span> to SAP host on port 33xx
          SnapLogic (JCo):  TCP SYN to port 3300
          PyRFC Mock:       <span class="success">✅ Listening on port 3300, accepts connection</span>

  <span class="dim">Step 2:</span> <span class="variable">Authenticate</span> with SysID, Client, User, Password
          SnapLogic (JCo):  Sends credentials via RFC handshake
          PyRFC Mock:       <span class="success">✅ Accepts ANY credentials (like Salesforce OAuth mock)</span>

  <span class="dim">Step 3:</span> <span class="variable">Test Call</span> — RFC_PING or RFC_SYSTEM_INFO
          SnapLogic (JCo):  Calls RFC_PING to verify connectivity
          PyRFC Mock:       <span class="success">✅ Returns success response</span>

  <span class="dim">Step 4:</span> <span class="variable">Result</span>
          SnapLogic:        <span class="success">✅ Account validated successfully!</span></div>

                <h3>SAP Account Configuration &mdash; Real vs Mock</h3>
                <p>The only thing that changes is the <strong>Application Server</strong> hostname &mdash; everything else stays the same:</p>

                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>SAP Account Parameter</th><th>Real SAP Value</th><th>Mock Server Value</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Application Server</strong></td>
                                <td><code>sap-prod.company.com</code></td>
                                <td><code>sap-mock-server</code> <span class="comment">(Docker container name)</span></td>
                            </tr>
                            <tr>
                                <td><strong>System Number</strong></td>
                                <td><code>00</code></td>
                                <td><code>00</code> (same)</td>
                            </tr>
                            <tr>
                                <td><strong>Client</strong></td>
                                <td><code>100</code></td>
                                <td><code>100</code> (same)</td>
                            </tr>
                            <tr>
                                <td><strong>User</strong></td>
                                <td><code>SNAP_USER</code></td>
                                <td><code>MOCK_USER</code> (accepts anything)</td>
                            </tr>
                            <tr>
                                <td><strong>Password</strong></td>
                                <td><code>realPassword</code></td>
                                <td><code>anything</code> (accepts anything)</td>
                            </tr>
                            <tr>
                                <td><strong>Language</strong></td>
                                <td><code>EN</code></td>
                                <td><code>EN</code> (same)</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="code-block">
<span class="label">Salesforce Account (what we do today):</span>
<span class="dim">─────────────────────────────────────────────────────────</span>
  Real:  Login URL = <span class="danger">https://login.salesforce.com</span>
  Mock:  Login URL = <span class="success">https://salesforce-api-mock:8443</span>
                     <span class="dim">^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
                     <span class="comment">Just change the hostname!</span>

<span class="label">SAP Account (same approach):</span>
<span class="dim">─────────────────────────────────────────────────────────</span>
  Real:  App Server = <span class="danger">sap-prod.company.com</span>
  Mock:  App Server = <span class="success">sap-mock-server</span>
                      <span class="dim">^^^^^^^^^^^^^^^</span>
                      <span class="comment">Just change the hostname!</span></div>

                <h3>Docker Compose &mdash; SAP Mock Server</h3>
                <div class="code-label">docker-compose.yml — SAP PyRFC Mock alongside Salesforce Mock</div>
                <div class="code-block">
<span class="keyword">services:</span>

  <span class="comment"># Salesforce mock (already working)</span>
  <span class="match">salesforce-api-mock:</span>
    build: ./docker/salesforce/django-server
    ports:
      - <span class="string">"8080:8080"</span>     <span class="comment"># HTTP</span>
      - <span class="string">"8443:8443"</span>     <span class="comment"># HTTPS</span>

  <span class="comment"># SAP RFC mock (new — PyRFC Smart Mock Server)</span>
  <span class="match">sap-mock-server:</span>
    build: ./docker/sap/pyrfc-server
    ports:
      - <span class="string">"3300:3300"</span>     <span class="comment"># RFC protocol (SAP Gateway port)</span>
    environment:
      - SAP_SYSNR=00
      - SAP_CLIENT=100
      - SAP_PROGRAM_ID=MOCK_SAP_SERVER</div>

                <h3>Common Concern: "But JCo is Licensed..."</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>Concern</th><th>Answer</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>JCo is licensed and proprietary</td>
                                <td>We don't use JCo. SnapLogic does. We use <strong>PyRFC</strong> (open source, Apache 2.0)</td>
                            </tr>
                            <tr>
                                <td>Do we need JCo on the mock server?</td>
                                <td><strong>No.</strong> JCo is only on the client side (SnapLogic). Our server uses PyRFC.</td>
                            </tr>
                            <tr>
                                <td>Does PyRFC need a license?</td>
                                <td>PyRFC itself is free (Apache 2.0). But it needs the <strong>SAP NW RFC SDK</strong> (C library) which requires SAP download access.</td>
                            </tr>
                            <tr>
                                <td>Is SAP NW RFC SDK free?</td>
                                <td>Free to download if you have an SAP account. Check if your SAP license covers dev/test usage.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

            </div>

            <!-- ═══════════════════════════════════════════════════════════
                 PART 2: PyRFC vs JCo — Full Comparison
                 ═══════════════════════════════════════════════════════════ -->
            <div class="data-section">
                <h2>PyRFC vs JCo &mdash; Weight, Size &amp; Features <span class="badge">Comparison</span></h2>

                <div class="info-box" style="background:#e8f5e9; border-left-color:#27ae60;">
                    <strong>Short answer:</strong> PyRFC is significantly more lightweight than JCo. Smaller Docker image, less memory, faster startup, and it fits our Python stack perfectly.
                </div>

                <h3>Resource Footprint</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>Resource</th><th>PyRFC (Python)</th><th>JCo (Java)</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Language Runtime</strong></td>
                                <td>Python (~50 MB)</td>
                                <td>JVM (~200-300 MB)</td>
                            </tr>
                            <tr>
                                <td><strong>Library Size</strong></td>
                                <td>PyRFC wheel (few MB) + SAP NW RFC SDK (~30 MB)</td>
                                <td>sapjco3.jar + native .so/.dll + SAP NW RFC SDK (~30 MB)</td>
                            </tr>
                            <tr>
                                <td><strong>Startup Memory</strong></td>
                                <td style="color:#27ae60; font-weight:bold;">~20-50 MB (Python process)</td>
                                <td style="color:#e74c3c; font-weight:bold;">~256 MB minimum (JVM heap requirement)</td>
                            </tr>
                            <tr>
                                <td><strong>Large IDoc Processing</strong></td>
                                <td>Python dicts, low overhead</td>
                                <td>Can consume 2-3 GB heap for large IDoc batch files</td>
                            </tr>
                            <tr>
                                <td><strong>Docker Image Size</strong></td>
                                <td style="color:#27ae60; font-weight:bold;">~150-200 MB</td>
                                <td style="color:#e74c3c; font-weight:bold;">~400-600 MB</td>
                            </tr>
                            <tr>
                                <td><strong>Startup Time</strong></td>
                                <td style="color:#27ae60; font-weight:bold;">Seconds (Python starts fast)</td>
                                <td style="color:#e74c3c; font-weight:bold;">5-15 seconds (JVM warmup + class loading)</td>
                            </tr>
                            <tr>
                                <td><strong>License</strong></td>
                                <td style="color:#27ae60;">Apache 2.0 (open source, free)</td>
                                <td style="color:#e74c3c;">SAP proprietary (cannot redistribute)</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Architecture Layers &mdash; PyRFC Has Fewer Layers</h3>
                <p>PyRFC calls the C library <strong>directly</strong> from Python. JCo adds an extra Java &rarr; JNI &rarr; C translation layer:</p>

                <div class="code-block">
<span class="success">PyRFC (Lightweight — fewer layers):</span>
<span class="dim">══════════════════════════════════════</span>

  <span class="success">Python Process</span> (~30 MB)
       <span class="dim">│</span>
       <span class="dim">v</span>
  <span class="success">PyRFC</span> (Python C Extension, few MB)
       <span class="dim">│</span>  <span class="comment">Direct C call — no translation layer</span>
       <span class="dim">v</span>
  <span class="match">SAP NW RFC SDK</span> (C library, ~30 MB)
       <span class="dim">│</span>
       <span class="dim">v</span>
  RFC Protocol on wire


<span class="warn">JCo (Heavyweight — extra layers):</span>
<span class="dim">══════════════════════════════════════</span>

  <span class="warn">JVM</span> (200-300 MB minimum heap)
       <span class="dim">│</span>
       <span class="dim">v</span>
  <span class="warn">sapjco3.jar</span> (Java library)
       <span class="dim">│</span>
       <span class="dim">v</span>
  <span class="warn">JNI Bridge</span> (Java ↔ C translation)   <span class="comment">← extra layer</span>
       <span class="dim">│</span>
       <span class="dim">v</span>
  <span class="warn">Native library</span> (libsapjco3.so / .dll)
       <span class="dim">│</span>
       <span class="dim">v</span>
  <span class="match">SAP NW RFC SDK</span> (C library, ~30 MB)
       <span class="dim">│</span>
       <span class="dim">v</span>
  RFC Protocol on wire</div>

                <h3>RFC Feature Support</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>Feature</th><th>PyRFC</th><th>JCo</th><th>Need for Mock?</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Client mode</strong> (call SAP)</td>
                                <td><span class="status-badge yes">YES</span></td>
                                <td><span class="status-badge yes">YES</span></td>
                                <td><span class="dim">Not needed &mdash; we are the server</span></td>
                            </tr>
                            <tr>
                                <td><strong>Server mode</strong> (receive calls)</td>
                                <td><span class="status-badge yes">YES</span></td>
                                <td><span class="status-badge yes">YES</span></td>
                                <td style="color:#27ae60; font-weight:bold;">✅ This is what we use</td>
                            </tr>
                            <tr>
                                <td><strong>Synchronous RFC (sRFC)</strong></td>
                                <td><span class="status-badge yes">YES</span></td>
                                <td><span class="status-badge yes">YES</span></td>
                                <td style="color:#27ae60; font-weight:bold;">✅ IDoc Read uses sRFC</td>
                            </tr>
                            <tr>
                                <td><strong>Asynchronous RFC (aRFC)</strong></td>
                                <td><span class="status-badge yes">YES</span></td>
                                <td><span class="status-badge yes">YES</span></td>
                                <td><span class="dim">Maybe for IDoc Write</span></td>
                            </tr>
                            <tr>
                                <td><strong>Transactional RFC (tRFC)</strong></td>
                                <td><span class="status-badge yes">YES</span></td>
                                <td><span class="status-badge yes">YES</span></td>
                                <td><span class="dim">Maybe for guaranteed delivery</span></td>
                            </tr>
                            <tr>
                                <td><strong>Queued RFC (qRFC)</strong></td>
                                <td><span class="status-badge no">NO</span></td>
                                <td><span class="status-badge yes">YES</span></td>
                                <td><span class="dim">Not needed for basic mocking</span></td>
                            </tr>
                            <tr>
                                <td><strong>Background RFC (bgRFC)</strong></td>
                                <td><span class="status-badge no">NO</span></td>
                                <td><span class="status-badge yes">YES</span></td>
                                <td><span class="dim">Not needed for basic mocking</span></td>
                            </tr>
                            <tr>
                                <td><strong>WebSocket RFC</strong></td>
                                <td><span class="status-badge no">NO</span></td>
                                <td><span class="status-badge yes">YES</span></td>
                                <td><span class="dim">Future — SnapLogic doesn't use it yet</span></td>
                            </tr>
                            <tr>
                                <td><strong>AS ABAP communication</strong></td>
                                <td><span class="status-badge yes">YES</span></td>
                                <td><span class="status-badge yes">YES</span></td>
                                <td style="color:#27ae60; font-weight:bold;">✅ Our mock acts as ABAP server</td>
                            </tr>
                            <tr>
                                <td><strong>AS Java communication</strong></td>
                                <td><span class="status-badge no">NO</span></td>
                                <td><span class="status-badge yes">YES</span></td>
                                <td><span class="dim">Not needed — mock is ABAP-type</span></td>
                            </tr>
                            <tr>
                                <td><strong>Connection pooling</strong></td>
                                <td>Basic</td>
                                <td>Advanced (built-in pool manager)</td>
                                <td><span class="dim">Not critical for mock server</span></td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="info-box" style="background:#fff3e0; border-left-color:#e67e22;">
                    <strong>Key limitation:</strong> PyRFC does <strong>NOT</strong> support communication with SAP AS Java stack &mdash; only ABAP stack. But this doesn't affect our mock server because: (1) We run as a <strong>server</strong> receiving calls, not a client calling SAP. (2) SnapLogic's SAP snap connects to our mock as if it were a standard ABAP system. (3) We're not connecting <em>to</em> a Java Application Server.
                </div>

                <h3>Server Mode Documentation &amp; Maturity</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>Aspect</th><th>PyRFC</th><th>JCo</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Server mode documentation</strong></td>
                                <td style="color:#e67e22;">Limited &mdash; examples exist but sparse docs</td>
                                <td style="color:#27ae60;">Extensive &mdash; official SAP guides + many blogs</td>
                            </tr>
                            <tr>
                                <td><strong>Server mode maturity</strong></td>
                                <td style="color:#e67e22;">Works but less battle-tested in production</td>
                                <td style="color:#27ae60;">Production-grade, used in enterprise integrations</td>
                            </tr>
                            <tr>
                                <td><strong>Community size</strong></td>
                                <td>Smaller (GitHub ~500 stars)</td>
                                <td>Large (enterprise standard for decades)</td>
                            </tr>
                            <tr>
                                <td><strong>Server example code</strong></td>
                                <td>Available on GitHub (examples/server/)</td>
                                <td>Available in SAP Community blogs + official docs</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <p><strong>For our use case</strong> (lightweight mock server, not production SAP integration), PyRFC's server mode documentation is sufficient. We are building a test mock, not a production middleware.</p>

                <h3>The Shared State Advantage &mdash; Why PyRFC Is the Clear Winner</h3>
                <p>This is the <strong>biggest reason</strong> PyRFC wins over JCo for our mock server:</p>

                <div class="code-block">
<span class="success">PyRFC — Same Python process, shared in-memory dict:</span>
<span class="dim">══════════════════════════════════════════════════════════</span>

  <span class="dim">┌──────────────────────────────────────────────────┐</span>
  <span class="dim">│</span>           <span class="success">Single Python Process</span>                   <span class="dim">│</span>
  <span class="dim">│</span>                                                  <span class="dim">│</span>
  <span class="dim">│</span>  <span class="success">PyRFC Server Thread</span>     <span class="success">Django Server Thread</span>  <span class="dim">│</span>
  <span class="dim">│</span>  (RFC on port 3300)      (HTTP on port 8443)     <span class="dim">│</span>
  <span class="dim">│</span>       <span class="dim">│</span>                          <span class="dim">│</span>               <span class="dim">│</span>
  <span class="dim">│</span>       <span class="dim">v</span>                          <span class="dim">v</span>               <span class="dim">│</span>
  <span class="dim">│</span>  <span class="match">┌────────────────────────────────────────────┐</span>  <span class="dim">│</span>
  <span class="dim">│</span>  <span class="match">│     database = {}  (shared Python dict)    │</span>  <span class="dim">│</span>
  <span class="dim">│</span>  <span class="match">│     Both threads read/write same dict!      │</span>  <span class="dim">│</span>
  <span class="dim">│</span>  <span class="match">└────────────────────────────────────────────┘</span>  <span class="dim">│</span>
  <span class="dim">│</span>                                                  <span class="dim">│</span>
  <span class="dim">│</span>  <span class="success">Zero overhead. No network. No serialization.</span>   <span class="dim">│</span>
  <span class="dim">└──────────────────────────────────────────────────┘</span>


<span class="danger">JCo — Separate JVM process, needs IPC:</span>
<span class="dim">══════════════════════════════════════════════════════════</span>

  <span class="dim">┌───────────────────┐</span>       <span class="dim">┌───────────────────┐</span>
  <span class="dim">│</span> <span class="warn">JVM Process</span>       <span class="dim">│</span>       <span class="dim">│</span> <span class="warn">Python Process</span>    <span class="dim">│</span>
  <span class="dim">│</span> JCo Server         <span class="dim">│</span>       <span class="dim">│</span> Django Server      <span class="dim">│</span>
  <span class="dim">│</span> (RFC on port 3300) <span class="dim">│</span>       <span class="dim">│</span> (HTTP on port 8443)<span class="dim">│</span>
  <span class="dim">│</span>     <span class="dim">│</span>              <span class="dim">│</span>       <span class="dim">│</span>      <span class="dim">│</span>             <span class="dim">│</span>
  <span class="dim">│</span>     <span class="dim">v</span>              <span class="dim">│</span>       <span class="dim">│</span>      <span class="dim">v</span>             <span class="dim">│</span>
  <span class="dim">│</span> <span class="warn">Java HashMap</span>      <span class="dim">│</span> <span class="danger">←?→</span>  <span class="dim">│</span> <span class="warn">Python dict</span>       <span class="dim">│</span>
  <span class="dim">│</span> (JCo's data)      <span class="dim">│</span>       <span class="dim">│</span> (Django's data)    <span class="dim">│</span>
  <span class="dim">└───────────────────┘</span>       <span class="dim">└───────────────────┘</span>
                        <span class="dim">│</span>
                        <span class="dim">v</span>
            <span class="danger">How to sync data between them?</span>
            <span class="danger">Redis? REST API? Shared DB?</span>
            <span class="danger">Extra complexity, extra latency!</span></div>

                <p>With <strong>PyRFC</strong>, the SAP RFC mock and the Salesforce Django mock can share the <strong>exact same Python dictionary</strong> in memory &mdash; zero overhead. A record created via Salesforce REST can be read via SAP RFC, or vice versa. With JCo, you'd need to build a whole synchronization layer between two separate processes.</p>

                <h3>Final Verdict &mdash; PyRFC Wins for Our Mock Server</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>Criteria</th><th>PyRFC</th><th>JCo</th><th>Winner</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Lightweight</strong></td>
                                <td>~150 MB Docker image</td>
                                <td>~500 MB Docker image</td>
                                <td style="color:#27ae60; font-weight:bold;">PyRFC ✅</td>
                            </tr>
                            <tr>
                                <td><strong>Startup memory</strong></td>
                                <td>~30-50 MB</td>
                                <td>~256 MB+ minimum</td>
                                <td style="color:#27ae60; font-weight:bold;">PyRFC ✅</td>
                            </tr>
                            <tr>
                                <td><strong>Startup speed</strong></td>
                                <td>Seconds</td>
                                <td>5-15 seconds</td>
                                <td style="color:#27ae60; font-weight:bold;">PyRFC ✅</td>
                            </tr>
                            <tr>
                                <td><strong>Fits our stack</strong></td>
                                <td>Python (same as Django mock)</td>
                                <td>Java (different language)</td>
                                <td style="color:#27ae60; font-weight:bold;">PyRFC ✅</td>
                            </tr>
                            <tr>
                                <td><strong>Shared state with Django</strong></td>
                                <td>Same process, shared dict</td>
                                <td>Separate process, needs IPC</td>
                                <td style="color:#27ae60; font-weight:bold;">PyRFC ✅</td>
                            </tr>
                            <tr>
                                <td><strong>License</strong></td>
                                <td>Apache 2.0 (free, open source)</td>
                                <td>SAP proprietary</td>
                                <td style="color:#27ae60; font-weight:bold;">PyRFC ✅</td>
                            </tr>
                            <tr>
                                <td><strong>Server mode docs</strong></td>
                                <td>Limited</td>
                                <td>Extensive</td>
                                <td style="color:#2980b9; font-weight:bold;">JCo</td>
                            </tr>
                            <tr>
                                <td><strong>Server mode maturity</strong></td>
                                <td>Works, less battle-tested</td>
                                <td>Production-grade</td>
                                <td style="color:#2980b9; font-weight:bold;">JCo</td>
                            </tr>
                            <tr>
                                <td><strong>Advanced RFC types</strong></td>
                                <td>sRFC, aRFC, tRFC</td>
                                <td>sRFC, aRFC, tRFC, qRFC, bgRFC</td>
                                <td style="color:#2980b9; font-weight:bold;">JCo</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="info-box" style="background:#e8f5e9; border-left-color:#27ae60;">
                    <strong>Bottom line:</strong> JCo wins on documentation and maturity. But for our use case &mdash; a <strong>lightweight test mock server</strong> that shares state with Django &mdash; PyRFC wins on every criteria that matters: weight, speed, memory, license, language fit, and shared state. We're building a test mock, not a production SAP middleware. PyRFC gives us everything we need with a fraction of the overhead.
                </div>
            </div>

            <div class="data-section">
                <h2>Summary <span class="badge">Key Takeaways</span></h2>

                <div class="info-box">
                    <strong>1. Compatibility:</strong> JCo (client) ↔ PyRFC (server) is a fully supported combination. They both wrap the same SAP NW RFC SDK (C library) and produce identical RFC protocol on the wire. The SAP snap cannot tell the difference between our PyRFC mock server and a real SAP system.<br><br>
                    <strong>2. Lightweight:</strong> PyRFC is significantly lighter than JCo &mdash; ~150 MB vs ~500 MB Docker image, ~30 MB vs ~256 MB memory, seconds vs 5-15 seconds startup.<br><br>
                    <strong>3. Shared state:</strong> PyRFC runs in the same Python process as Django, sharing the same in-memory dictionary. JCo would require a separate JVM process with complex inter-process communication.<br><br>
                    <strong>4. Trade-off accepted:</strong> JCo has better server mode documentation and supports more RFC types. For a test mock server, this trade-off is acceptable &mdash; we only need sRFC and tRFC, which PyRFC fully supports.
                </div>
            </div>
        </div>

        <!-- ═══════════════════════════════════════════════════════════════
             TAB 12: IMPLEMENTATION PLAN
             ═══════════════════════════════════════════════════════════════ -->
        <div id="impl-plan" class="tab-content">
            <div class="data-section">
                <h2>SAP PyRFC Mock Server &mdash; Implementation Plan <span class="badge purple">Step-by-Step</span></h2>

                <p>A phased plan to build the SAP PyRFC Smart Mock Server, following the exact same architecture as the Salesforce Django mock server. Each phase builds on the previous one.</p>

                <div class="info-box" style="background:#f3e5f5; border-left-color:#7b1fa2;">
                    <strong>Architecture goal:</strong> Single Python process with two threads &mdash; PyRFC server on port 3300 (handles SAP snap RFC calls) + Django HTTP admin on port 8080 (handles Robot Framework reset/status). Both share the same <code>sap_database = {}</code> dict in memory.
                </div>
            </div>

            <!-- Phase 0 -->
            <div class="data-section">
                <h2>Phase 0: Prerequisites &amp; Research <span class="badge red">Do This First</span></h2>
                <p>Before writing any code, validate that PyRFC server mode actually works. This is the biggest risk &mdash; if it fails, the plan changes.</p>

                <div class="flow-step">
                    <div class="flow-number orange">0.1</div>
                    <div class="flow-content">
                        <h4>Download SAP NW RFC SDK</h4>
                        <p>Download the <strong>Linux x86_64</strong> version from SAP Software Download Center. Requires an SAP account. This is the C library that PyRFC wraps.</p>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number orange">0.2</div>
                    <div class="flow-content">
                        <h4>Verify PyRFC Server Mode Works</h4>
                        <p>Install PyRFC locally. Write a minimal 10-line RFC server that listens on port 3300 and responds to <code>RFC_PING</code>. If this works, proceed. If not, fall back to Option 1 (Mock at SnapLogic Layer).</p>
                        <div class="code-block">
<span class="comment"># Minimal test — does PyRFC server mode actually work?</span>
<span class="keyword">from</span> pyrfc <span class="keyword">import</span> Server

<span class="keyword">def</span> <span class="function">handle_ping</span>(request_context):
    <span class="keyword">return</span> {}  <span class="comment"># Just return empty — proves server mode works</span>

server = Server(server_params={...})
server.add_function(<span class="string">'RFC_PING'</span>, handle_ping)
server.serve()  <span class="comment"># Does it listen? Does it respond?</span></div>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number orange">0.3</div>
                    <div class="flow-content">
                        <h4>Capture Real IDoc Response from Dev SAP</h4>
                        <p>Run the SnapLogic SAP IDoc Read pipeline against a Dev SAP system. Save the <strong>actual IDoc response</strong> as JSON. This becomes the reference schema for the mock &mdash; we build the mock to return data in this exact format.</p>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number orange">0.4</div>
                    <div class="flow-content">
                        <h4>Identify Exact BAPIs/RFCs SnapLogic Calls</h4>
                        <p>Enable RFC tracing or check SnapLogic execution logs to identify the exact function names and parameters the SAP snap sends. Key functions to discover:</p>
                        <div class="code-block">
<span class="label">Account Validation (what does SnapLogic call first?):</span>
  <span class="variable">RFC_PING</span>                          <span class="comment">?  Simple connectivity check</span>
  <span class="variable">RFC_SYSTEM_INFO</span>                   <span class="comment">?  System info request</span>
  <span class="variable">RFC_METADATA_GET</span>                  <span class="comment">?  Function metadata discovery</span>

<span class="label">IDoc Operations (the actual work):</span>
  <span class="variable">Z_SNAP_IDOC_READ_COMPLETELY</span>       <span class="comment">✓  We know this one (IDoc Read)</span>
  <span class="variable">IDOC_INBOUND_ASYNCHRONOUS</span>         <span class="comment">?  IDoc Write/Send</span>
  <span class="variable">IDOC_STATUS_WRITE_TO_DATABASE</span>     <span class="comment">?  Status update</span></div>
                    </div>
                </div>

                <div class="info-box red">
                    <strong>Gate check:</strong> If Phase 0.2 fails (PyRFC server mode doesn't work reliably), <strong>STOP HERE</strong> and use Option 1 (Mock at SnapLogic Layer) instead. Don't invest in building something on a broken foundation.
                </div>
            </div>

            <!-- Phase 1 -->
            <div class="data-section">
                <h2>Phase 1: Project Structure <span class="badge">Scaffolding</span></h2>
                <p>Create the folder structure, mirroring the Salesforce mock server exactly:</p>

                <div class="code-block">
<span class="label">Salesforce Mock (reference):</span>                <span class="label">SAP PyRFC Mock (to create):</span>
<span class="dim">docker/salesforce/django-server/</span>              <span class="match">docker/sap/pyrfc-server/</span>
<span class="dim">├──</span> Dockerfile                                 <span class="dim">├──</span> Dockerfile
<span class="dim">├──</span> entrypoint.sh                              <span class="dim">├──</span> entrypoint.sh
<span class="dim">├──</span> run_server.py                              <span class="dim">├──</span> run_server.py
<span class="dim">├──</span> requirements.txt                           <span class="dim">├──</span> requirements.txt
<span class="dim">│</span>                                              <span class="dim">│</span>
<span class="dim">├──</span> salesforce_mock/                            <span class="dim">├──</span> <span class="match">sap_mock/</span>
<span class="dim">│</span>   <span class="dim">├──</span> state/                                <span class="dim">│</span>   <span class="dim">├──</span> <span class="match">state/</span>
<span class="dim">│</span>   <span class="dim">│</span>   <span class="dim">├──</span> <span class="success">database.py</span>                    <span class="dim">│</span>   <span class="dim">│</span>   <span class="dim">├──</span> <span class="success">database.py</span>
<span class="dim">│</span>   <span class="dim">│</span>   <span class="dim">├──</span> job_store.py                    <span class="dim">│</span>   <span class="dim">│</span>   <span class="dim">└──</span> counters.py
<span class="dim">│</span>   <span class="dim">│</span>   <span class="dim">└──</span> event_bus.py                    <span class="dim">│</span>   <span class="dim">│</span>
<span class="dim">│</span>   <span class="dim">├──</span> views/                                <span class="dim">│</span>   <span class="dim">├──</span> <span class="match">handlers/</span>
<span class="dim">│</span>   <span class="dim">│</span>   <span class="dim">├──</span> rest_views.py                   <span class="dim">│</span>   <span class="dim">│</span>   <span class="dim">├──</span> <span class="success">system_handlers.py</span>
<span class="dim">│</span>   <span class="dim">│</span>   <span class="dim">├──</span> bulk_v1_views.py                <span class="dim">│</span>   <span class="dim">│</span>   <span class="dim">├──</span> <span class="success">idoc_handlers.py</span>
<span class="dim">│</span>   <span class="dim">│</span>   <span class="dim">├──</span> admin_views.py                  <span class="dim">│</span>   <span class="dim">│</span>   <span class="dim">├──</span> <span class="success">bapi_handlers.py</span>
<span class="dim">│</span>   <span class="dim">│</span>   <span class="dim">└──</span> ...                              <span class="dim">│</span>   <span class="dim">│</span>   <span class="dim">└──</span> <span class="success">admin_handlers.py</span>
<span class="dim">│</span>   <span class="dim">├──</span> parsers/                              <span class="dim">│</span>   <span class="dim">├──</span> <span class="match">metadata/</span>
<span class="dim">│</span>   <span class="dim">│</span>   <span class="dim">├──</span> soql_parser.py                  <span class="dim">│</span>   <span class="dim">│</span>   <span class="dim">└──</span> <span class="success">function_definitions.py</span>
<span class="dim">│</span>   <span class="dim">│</span>   <span class="dim">└──</span> sosl_parser.py                  <span class="dim">│</span>   <span class="dim">│</span>
<span class="dim">│</span>   <span class="dim">└──</span> utils/                                <span class="dim">│</span>   <span class="dim">└──</span> <span class="match">utils/</span>
<span class="dim">│</span>       <span class="dim">├──</span> id_generator.py                   <span class="dim">│</span>       <span class="dim">└──</span> doc_number_generator.py
<span class="dim">│</span>       <span class="dim">├──</span> error_formatter.py                <span class="dim">│</span>
<span class="dim">│</span>       <span class="dim">└──</span> validator.py                      <span class="dim">├──</span> <span class="match">schemas/</span>
<span class="dim">│</span>                                              <span class="dim">│</span>   <span class="dim">├──</span> ORDERS05.json
<span class="dim">├──</span> schemas/                                   <span class="dim">│</span>   <span class="dim">├──</span> MATMAS05.json
<span class="dim">│</span>   <span class="dim">├──</span> Account.json                         <span class="dim">│</span>   <span class="dim">└──</span> DEBMAS07.json
<span class="dim">│</span>   <span class="dim">├──</span> Contact.json                         <span class="dim">│</span>
<span class="dim">│</span>   <span class="dim">└──</span> ...                                  <span class="dim">└──</span> docker-compose.sap-pyrfc.yml
<span class="dim">│</span>
<span class="dim">└──</span> docker-compose.salesforce-django.yml</div>
            </div>

            <!-- Phase 2 -->
            <div class="data-section">
                <h2>Phase 2: In-Memory Database <span class="badge">State Layer</span></h2>
                <p>Build the state management layer &mdash; direct copy of the Salesforce pattern.</p>

                <div class="flow-step">
                    <div class="flow-number">2.1</div>
                    <div class="flow-content">
                        <h4>state/database.py &mdash; In-Memory SAP Database</h4>
                        <p>Create <code>sap_database = {}</code> dict with sections for each SAP object type. Create <code>schemas = {}</code> for IDoc type definitions. Create <code>reset_all()</code> function.</p>
                        <div class="code-block">
<span class="comment"># Same pattern as salesforce_mock/state/database.py</span>
sap_database = {
    <span class="string">'IDOC'</span>: {},          <span class="comment"># DOCNUM → full IDoc record</span>
    <span class="string">'CUSTOMER'</span>: {},      <span class="comment"># KUNNR → customer master</span>
    <span class="string">'MATERIAL'</span>: {},      <span class="comment"># MATNR → material master</span>
    <span class="string">'SALES_ORDER'</span>: {},   <span class="comment"># VBELN → sales order</span>
}

<span class="keyword">def</span> <span class="function">reset_all</span>():
    <span class="string">"""Clear all records (called between tests for clean state)."""</span>
    ...</div>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number">2.2</div>
                    <div class="flow-content">
                        <h4>state/counters.py &mdash; Document Number Generator</h4>
                        <p>Create <code>generate_doc_number(doc_type)</code> that returns 10-digit zero-padded sequential numbers like <code>0000001001</code>. Same concept as Salesforce's <code>id_generator.py</code>.</p>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number">2.3</div>
                    <div class="flow-content">
                        <h4>schemas/ORDERS05.json &mdash; IDoc Type Definition</h4>
                        <p>Define the IDoc structure from the real captured response (Phase 0.3). List segment names (<code>E1EDK01</code>, <code>E1EDP01</code>, etc.), field names, and types. This is the SAP equivalent of <code>schemas/Account.json</code>.</p>
                    </div>
                </div>
            </div>

            <!-- Phase 3 -->
            <div class="data-section">
                <h2>Phase 3: System Handlers &mdash; Account Validation <span class="badge red">Build This First</span></h2>
                <p>This is the <strong>first thing SnapLogic calls</strong> when you click "Validate" on an SAP account. If this works, everything else is just adding more handlers.</p>

                <div class="flow-step">
                    <div class="flow-number">3.1</div>
                    <div class="flow-content">
                        <h4>handlers/system_handlers.py &mdash; RFC_PING</h4>
                        <p>Simplest possible handler. Return empty success response. SnapLogic sends this to check connectivity.</p>
                        <div class="code-block">
<span class="keyword">def</span> <span class="function">handle_rfc_ping</span>(request_context):
    <span class="string">"""RFC_PING — connectivity check. Just return success."""</span>
    <span class="keyword">return</span> {}</div>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number">3.2</div>
                    <div class="flow-content">
                        <h4>handlers/system_handlers.py &mdash; RFC_SYSTEM_INFO</h4>
                        <p>Return mock system information. SnapLogic may call this during account validation to discover the SAP system details.</p>
                        <div class="code-block">
<span class="keyword">def</span> <span class="function">handle_system_info</span>(request_context):
    <span class="string">"""RFC_SYSTEM_INFO — return mock SAP system details."""</span>
    <span class="keyword">return</span> {
        <span class="string">'RFCSI_EXPORT'</span>: {
            <span class="string">'RFCDEST'</span>: <span class="string">'MOCK_SAP_SERVER'</span>,
            <span class="string">'RFCHOST'</span>: <span class="string">'sap-mock-server'</span>,
            <span class="string">'RFCSYSID'</span>: <span class="string">'MCK'</span>,
            <span class="string">'RFCDBHOST'</span>: <span class="string">'mock-db'</span>,
            <span class="string">'RFCDBSYS'</span>: <span class="string">'MOCK'</span>,
            <span class="string">'RFCCLIENT'</span>: <span class="string">'100'</span>,
        }
    }</div>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number">3.3</div>
                    <div class="flow-content">
                        <h4>Test: SnapLogic Account Validation</h4>
                        <p>Point a SnapLogic SAP account at the mock server (<code>sap-mock-server:3300</code>). Click <strong>Validate</strong>. If it shows ✅ &mdash; account validation works! This is the first milestone.</p>
                        <div class="code-block">
<span class="label">SnapLogic SAP Account Settings:</span>
  Application Server:  <span class="success">sap-mock-server</span>    <span class="comment">(Docker container name)</span>
  System Number:       <span class="variable">00</span>
  Client:              <span class="variable">100</span>
  User:                <span class="variable">MOCK_USER</span>          <span class="comment">(mock accepts anything)</span>
  Password:            <span class="variable">anything</span>           <span class="comment">(mock accepts anything)</span>

  Click [Validate] → <span class="success">✅ Account validated!</span></div>
                    </div>
                </div>
            </div>

            <!-- Phase 4 -->
            <div class="data-section">
                <h2>Phase 4: IDoc Handlers &mdash; Core CRUD <span class="badge blue">Main Work</span></h2>
                <p>Build the IDoc Create/Read/Update/Delete handlers. Each one reads from or writes to <code>sap_database['IDOC']</code>.</p>

                <div class="flow-step">
                    <div class="flow-number blue">4.1</div>
                    <div class="flow-content">
                        <h4>handlers/idoc_handlers.py &mdash; READ (Z_SNAP_IDOC_READ_COMPLETELY)</h4>
                        <p>Look up IDoc by <code>DOCUMENT_NUMBER</code> from <code>sap_database['IDOC']</code>. Return full IDoc structure (IDOC_CONTROL, INT_EDIDD, INT_EDIDS). Return error if not found.</p>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number blue">4.2</div>
                    <div class="flow-content">
                        <h4>handlers/idoc_handlers.py &mdash; CREATE (IDOC_INBOUND_ASYNCHRONOUS)</h4>
                        <p>Generate document number via <code>generate_doc_number('IDOC')</code>. Store full IDoc in <code>sap_database['IDOC'][doc_num]</code>. Return DOCNUM and status.</p>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number blue">4.3</div>
                    <div class="flow-content">
                        <h4>handlers/idoc_handlers.py &mdash; UPDATE (IDOC_STATUS_WRITE_TO_DATABASE)</h4>
                        <p>Find existing IDoc in <code>sap_database['IDOC']</code>. Modify status field. Append new entry to status records (INT_EDIDS). Return success.</p>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number blue">4.4</div>
                    <div class="flow-content">
                        <h4>handlers/idoc_handlers.py &mdash; DELETE (Z_MOCK_DELETE_IDOC)</h4>
                        <p>Custom mock function for test cleanup. Remove IDoc from <code>sap_database['IDOC']</code>. Return success or error if not found.</p>
                    </div>
                </div>

                <div class="code-block">
<span class="label">CRUD Test Lifecycle (same as Salesforce mock):</span>
<span class="dim">─────────────────────────────────────────────────────────────────</span>
  Step 1: RFC <span class="variable">IDOC_INBOUND_ASYNCHRONOUS</span>     <span class="arrow">→</span> <span class="success">Creates in sap_database['IDOC']</span>
          Returns: { DOCNUM: "0000001001" }

  Step 2: RFC <span class="variable">Z_SNAP_IDOC_READ_COMPLETELY</span>   <span class="arrow">→</span> <span class="success">Finds THAT IDoc from dict</span>
          Returns: { IDOC_CONTROL: {...}, INT_EDIDD: [...] }

  Step 3: RFC <span class="variable">IDOC_STATUS_WRITE</span>             <span class="arrow">→</span> <span class="success">Updates status in-memory</span>
          Returns: { SUCCESS: 'X' }

  Step 4: RFC <span class="variable">Z_MOCK_DELETE_IDOC</span>             <span class="arrow">→</span> <span class="success">Removes from dict</span>
  Step 5: RFC <span class="variable">Z_SNAP_IDOC_READ_COMPLETELY</span>   <span class="arrow">→</span> <span class="danger">ERROR: IDoc does not exist!</span></div>
            </div>

            <!-- Phase 5 -->
            <div class="data-section">
                <h2>Phase 5: RFC Function Metadata Definitions <span class="badge orange">Tedious but Required</span></h2>
                <p>PyRFC server mode requires you to <strong>define the parameter metadata</strong> (names, types, direction) for each RFC function before registering it. This tells PyRFC what parameters to expect and return &mdash; like defining a REST API schema.</p>

                <div class="flow-step">
                    <div class="flow-number orange">5.1</div>
                    <div class="flow-content">
                        <h4>metadata/function_definitions.py &mdash; Z_SNAP_IDOC_READ_COMPLETELY</h4>
                        <p>Define import params (<code>DOCUMENT_NUMBER</code>), export params (<code>IDOC_CONTROL</code>, <code>INT_EDIDD</code>, <code>INT_EDIDS</code>, record counts). Use the captured real response from Phase 0.3 as reference.</p>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number orange">5.2</div>
                    <div class="flow-content">
                        <h4>metadata/function_definitions.py &mdash; IDOC_INBOUND_ASYNCHRONOUS</h4>
                        <p>Define import params (<code>IDOC_CONTROL</code>, <code>IDOC_DATA</code>). These are the table parameters PyRFC needs to accept the incoming IDoc data.</p>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number orange">5.3</div>
                    <div class="flow-content">
                        <h4>metadata/function_definitions.py &mdash; System Functions</h4>
                        <p>Define <code>RFC_PING</code> (no params), <code>RFC_SYSTEM_INFO</code> (export: RFCSI_EXPORT structure). These are simple and well-documented.</p>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number orange">5.4</div>
                    <div class="flow-content">
                        <h4>metadata/function_definitions.py &mdash; Admin Functions</h4>
                        <p>Define <code>Z_MOCK_RESET_DATABASE</code> (export: RECORDS_CLEARED), <code>Z_MOCK_GET_STATUS</code> (export: database counts). These are custom mock functions for test management.</p>
                    </div>
                </div>

                <div class="info-box" style="background:#fff3e0; border-left-color:#e67e22;">
                    <strong>Why this is tedious:</strong> PyRFC needs to know the exact structure of every parameter (name, type, length, direction) before it can accept or return data. In REST/Django, you just return a dict. In RFC, you must pre-declare the schema. Build from the real captured response &mdash; don't guess.
                </div>
            </div>

            <!-- Phase 6 -->
            <div class="data-section">
                <h2>Phase 6: Server Startup (run_server.py) <span class="badge">Core Architecture</span></h2>
                <p>The main server script &mdash; same dual-thread pattern as the Salesforce mock's <code>run_server.py</code>.</p>

                <div class="flow-step">
                    <div class="flow-number purple">6.1</div>
                    <div class="flow-content">
                        <h4>PyRFC Server Thread (port 3300)</h4>
                        <p>Create PyRFC <code>Server</code> instance. Register all function handlers from Phase 3 &amp; 4 (system_handlers + idoc_handlers). Start listening on port 3300.</p>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number purple">6.2</div>
                    <div class="flow-content">
                        <h4>Django HTTP Admin Thread (port 8080)</h4>
                        <p>Lightweight Django app with only admin endpoints: <code>/health</code>, <code>/__admin/reset</code>, <code>/__admin/status</code>. This lets Robot Framework call reset/inspect via HTTP (same as Salesforce mock). Shares the same <code>sap_database</code> dict.</p>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number purple">6.3</div>
                    <div class="flow-content">
                        <h4>Schema Loading at Startup</h4>
                        <p>Read <code>schemas/*.json</code> files at startup. Populate <code>sap_database</code> structure. Same as Salesforce's <code>apps.py ready()</code> pattern.</p>
                    </div>
                </div>

                <div class="code-block">
<span class="label">Dual-Thread Architecture (mirrors Salesforce mock's run_server.py):</span>

  <span class="dim">┌──────────────────────────────────────────────────────────┐</span>
  <span class="dim">│</span>              <span class="match">Single Python Process</span>                       <span class="dim">│</span>
  <span class="dim">│</span>                                                          <span class="dim">│</span>
  <span class="dim">│</span>  <span class="dim">┌──────────────────────┐</span>  <span class="dim">┌──────────────────────────┐</span>  <span class="dim">│</span>
  <span class="dim">│</span>  <span class="dim">│</span> <span class="success">Main Thread</span>          <span class="dim">│</span>  <span class="dim">│</span> <span class="success">Child Thread</span>             <span class="dim">│</span>  <span class="dim">│</span>
  <span class="dim">│</span>  <span class="dim">│</span> PyRFC RFC Server     <span class="dim">│</span>  <span class="dim">│</span> Django HTTP Admin        <span class="dim">│</span>  <span class="dim">│</span>
  <span class="dim">│</span>  <span class="dim">│</span> Port 3300            <span class="dim">│</span>  <span class="dim">│</span> Port 8080                <span class="dim">│</span>  <span class="dim">│</span>
  <span class="dim">│</span>  <span class="dim">│</span>                      <span class="dim">│</span>  <span class="dim">│</span>                          <span class="dim">│</span>  <span class="dim">│</span>
  <span class="dim">│</span>  <span class="dim">│</span> Handles:             <span class="dim">│</span>  <span class="dim">│</span> Handles:                 <span class="dim">│</span>  <span class="dim">│</span>
  <span class="dim">│</span>  <span class="dim">│</span>  RFC_PING             <span class="dim">│</span>  <span class="dim">│</span>  GET  /health             <span class="dim">│</span>  <span class="dim">│</span>
  <span class="dim">│</span>  <span class="dim">│</span>  RFC_SYSTEM_INFO      <span class="dim">│</span>  <span class="dim">│</span>  POST /__admin/reset      <span class="dim">│</span>  <span class="dim">│</span>
  <span class="dim">│</span>  <span class="dim">│</span>  Z_SNAP_IDOC_READ..   <span class="dim">│</span>  <span class="dim">│</span>  GET  /__admin/status     <span class="dim">│</span>  <span class="dim">│</span>
  <span class="dim">│</span>  <span class="dim">│</span>  IDOC_INBOUND_ASYNC   <span class="dim">│</span>  <span class="dim">│</span>  GET  /__admin/database   <span class="dim">│</span>  <span class="dim">│</span>
  <span class="dim">│</span>  <span class="dim">│</span>  IDOC_STATUS_WRITE    <span class="dim">│</span>  <span class="dim">│</span>                          <span class="dim">│</span>  <span class="dim">│</span>
  <span class="dim">│</span>  <span class="dim">└───────────┬──────────┘</span>  <span class="dim">└────────────┬─────────────┘</span>  <span class="dim">│</span>
  <span class="dim">│</span>              <span class="dim">│</span>                          <span class="dim">│</span>                  <span class="dim">│</span>
  <span class="dim">│</span>              <span class="dim">v</span>                          <span class="dim">v</span>                  <span class="dim">│</span>
  <span class="dim">│</span>  <span class="match">┌───────────────────────────────────────────────────┐</span>  <span class="dim">│</span>
  <span class="dim">│</span>  <span class="match">│            sap_database = {} (shared dict)         │</span>  <span class="dim">│</span>
  <span class="dim">│</span>  <span class="match">│            Both threads read/write same dict        │</span>  <span class="dim">│</span>
  <span class="dim">│</span>  <span class="match">└───────────────────────────────────────────────────┘</span>  <span class="dim">│</span>
  <span class="dim">└──────────────────────────────────────────────────────────┘</span></div>
            </div>

            <!-- Phase 7 -->
            <div class="data-section">
                <h2>Phase 7: Docker Setup <span class="badge">Containerization</span></h2>

                <div class="flow-step">
                    <div class="flow-number">7.1</div>
                    <div class="flow-content">
                        <h4>Dockerfile</h4>
                        <p>Base image: <code>python:3.11-slim</code>. Copy SAP NW RFC SDK <code>.so</code> files into the image. Set <code>LD_LIBRARY_PATH</code>. Install pyrfc + Django. Copy application code + schemas.</p>
                        <div class="code-block">
<span class="keyword">FROM</span> python:3.11-slim

<span class="comment"># Install SAP NW RFC SDK (C library)</span>
<span class="keyword">COPY</span> nwrfcsdk/ /usr/local/sap/nwrfcsdk/
<span class="keyword">ENV</span> LD_LIBRARY_PATH=/usr/local/sap/nwrfcsdk/lib
<span class="keyword">ENV</span> SAPNWRFC_HOME=/usr/local/sap/nwrfcsdk

<span class="comment"># Install Python dependencies</span>
<span class="keyword">COPY</span> requirements.txt ./
<span class="keyword">RUN</span> pip install --no-cache-dir -r requirements.txt

<span class="comment"># Copy application</span>
<span class="keyword">COPY</span> sap_mock/ ./sap_mock/
<span class="keyword">COPY</span> schemas/ ./schemas/
<span class="keyword">COPY</span> run_server.py ./

<span class="keyword">EXPOSE</span> 3300 8080
<span class="keyword">CMD</span> [<span class="string">"python"</span>, <span class="string">"-u"</span>, <span class="string">"run_server.py"</span>]</div>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number">7.2</div>
                    <div class="flow-content">
                        <h4>entrypoint.sh</h4>
                        <p>Set <code>LD_LIBRARY_PATH</code> for SAP NW RFC SDK native libraries. Verify SDK is present. Start <code>python run_server.py</code>.</p>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number">7.3</div>
                    <div class="flow-content">
                        <h4>requirements.txt</h4>
                        <div class="code-block">
pyrfc>=3.3
Django>=4.2,<5.0</div>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number">7.4</div>
                    <div class="flow-content">
                        <h4>docker-compose.sap-pyrfc.yml</h4>
                        <div class="code-block">
<span class="keyword">services:</span>
  <span class="match">sap-mock-server:</span>
    build: ./docker/sap/pyrfc-server
    container_name: sap-mock-server
    ports:
      - <span class="string">"3300:3300"</span>     <span class="comment"># RFC protocol (SAP Gateway)</span>
      - <span class="string">"8180:8080"</span>     <span class="comment"># HTTP admin (reset, health, status)</span>
    environment:
      - SAP_SYSNR=00
      - SAP_CLIENT=100
      - SAP_PROGRAM_ID=MOCK_SAP_SERVER
      - SCHEMA_DIR=/app/schemas
    healthcheck:
      test: [<span class="string">"CMD"</span>, <span class="string">"curl"</span>, <span class="string">"-f"</span>, <span class="string">"http://localhost:8080/health"</span>]
      interval: 10s
      timeout: 5s
      retries: 3
    networks:
      - snaplogicnet</div>
                    </div>
                </div>
            </div>

            <!-- Phase 8 -->
            <div class="data-section">
                <h2>Phase 8: Integration Test <span class="badge">Prove It Works</span></h2>
                <p>End-to-end verification that the mock server works with SnapLogic.</p>

                <div class="flow-step">
                    <div class="flow-number">8.1</div>
                    <div class="flow-content">
                        <h4>Start Container</h4>
                        <p><code>docker-compose up sap-mock-server</code> &mdash; verify PyRFC listens on 3300, admin HTTP on 8080.</p>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number blue">8.2</div>
                    <div class="flow-content">
                        <h4>Verify Admin HTTP</h4>
                        <div class="code-block">
<span class="comment"># Health check</span>
curl http://localhost:8180/health
<span class="arrow">→</span> <span class="success">{ "status": "healthy", "rfc_server": "running", "port": 3300 }</span>

<span class="comment"># Reset database</span>
curl -X POST http://localhost:8180/__admin/reset
<span class="arrow">→</span> <span class="success">{ "status": "reset", "recordsCleared": 0 }</span>

<span class="comment"># Check database status</span>
curl http://localhost:8180/__admin/status
<span class="arrow">→</span> <span class="success">{ "IDOC": 0, "CUSTOMER": 0, "MATERIAL": 0 }</span></div>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number purple">8.3</div>
                    <div class="flow-content">
                        <h4>SnapLogic Account Validation</h4>
                        <p>Create SAP account pointing to <code>sap-mock-server:3300</code>. Click Validate. Should pass ✅.</p>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number">8.4</div>
                    <div class="flow-content">
                        <h4>IDoc Read Pipeline</h4>
                        <p>Run SAP IDoc Read pipeline against mock. Should get mock IDoc response from in-memory database.</p>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number orange">8.5</div>
                    <div class="flow-content">
                        <h4>Full CRUD Cycle</h4>
                        <p>Run IDoc Write pipeline (creates IDoc in mock) &rarr; Run IDoc Read pipeline (reads it back) &rarr; Verify data matches. This proves the smart mock pattern works end-to-end.</p>
                    </div>
                </div>
            </div>

            <!-- Phase 9 -->
            <div class="data-section">
                <h2>Phase 9: Robot Framework Integration <span class="badge blue">Test Automation</span></h2>

                <div class="flow-step">
                    <div class="flow-number blue">9.1</div>
                    <div class="flow-content">
                        <h4>Add to Main docker-compose.yml</h4>
                        <p>Add <code>sap-mock-server</code> alongside <code>salesforce-api-mock</code> in the main docker-compose file.</p>
                        <div class="code-block">
<span class="keyword">services:</span>
  <span class="success">salesforce-api-mock:</span>      <span class="comment"># ← Already exists</span>
    build: ./docker/salesforce/django-server
    ports: [<span class="string">"8080:8080"</span>, <span class="string">"8443:8443"</span>]

  <span class="match">sap-mock-server:</span>           <span class="comment"># ← NEW</span>
    build: ./docker/sap/pyrfc-server
    ports: [<span class="string">"3300:3300"</span>, <span class="string">"8180:8080"</span>]</div>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number blue">9.2</div>
                    <div class="flow-content">
                        <h4>Create Robot Framework Keywords</h4>
                        <p>Build reusable keywords for SAP mock management (same pattern as Salesforce mock keywords):</p>
                        <div class="code-block">
<span class="label">*** Keywords ***</span>
<span class="function">Reset SAP Mock Database</span>
    POST    http://sap-mock-server:8080/__admin/reset

<span class="function">Get SAP Mock Status</span>
    ${resp}=    GET    http://sap-mock-server:8080/__admin/status
    RETURN    ${resp.json()}</div>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number blue">9.3</div>
                    <div class="flow-content">
                        <h4>Write First Robot Test</h4>
                        <div class="code-block">
<span class="label">*** Test Cases ***</span>
<span class="function">SAP IDoc Create And Read Back</span>
    [Setup]    Reset SAP Mock Database
    <span class="comment"># Step 1: Pipeline writes IDoc via SAP snap → stored in mock</span>
    Execute Pipeline    SAP_IDoc_Write_Pipeline
    <span class="comment"># Step 2: Pipeline reads IDoc via SAP snap → returned from mock</span>
    ${result}=    Execute Pipeline    SAP_IDoc_Read_Pipeline
    <span class="comment"># Step 3: Verify</span>
    Should Be Equal    ${result.IDOC_CONTROL.IDOCTP}    ORDERS05
    [Teardown]    Reset SAP Mock Database</div>
                    </div>
                </div>
            </div>

            <!-- Phase 10 -->
            <div class="data-section">
                <h2>Phase 10: Plugin Architecture <span class="badge gray-tab">Future</span></h2>
                <p>Merge SAP mock into the unified SLIM Mock Service alongside Salesforce.</p>

                <div class="flow-step">
                    <div class="flow-number gray">10.1</div>
                    <div class="flow-content">
                        <h4>Move into plugins/ Folder</h4>
                        <p>Restructure: <code>plugins/sap_rfc/</code> alongside <code>plugins/salesforce/</code> inside a unified SLIM Mock Service container.</p>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number gray">10.2</div>
                    <div class="flow-content">
                        <h4>Environment Variable Control</h4>
                        <p>Support <code>MOCK_PLUGINS=salesforce,sap_rfc</code> to dynamically load plugins.</p>
                    </div>
                </div>
                <div class="flow-step">
                    <div class="flow-number gray">10.3</div>
                    <div class="flow-content">
                        <h4>Shared Database Across Plugins</h4>
                        <p>Single <code>database = {}</code> dict shared by both Salesforce HTTP handlers and SAP RFC handlers in the same Python process. A record created via Salesforce REST can be referenced by SAP RFC, if needed for cross-system pipeline testing.</p>
                    </div>
                </div>
            </div>

            <!-- Risks -->
            <div class="data-section">
                <h2>Risks &amp; Decision Points <span class="badge red">Watch Out</span></h2>

                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>Risk</th><th>Impact</th><th>Mitigation</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>PyRFC server mode doesn't work properly</strong></td>
                                <td style="color:#e74c3c; font-weight:bold;">High &mdash; blocks entire plan</td>
                                <td>Phase 0.2 tests this FIRST before writing anything. Fallback: Option 1 (Mock at SnapLogic Layer)</td>
                            </tr>
                            <tr>
                                <td><strong>SAP NW RFC SDK licensing blocks Docker usage</strong></td>
                                <td style="color:#e67e22; font-weight:bold;">Medium</td>
                                <td>Check with SAP licensing team. SDK is free to download; redistribution may have limits</td>
                            </tr>
                            <tr>
                                <td><strong>Don't know exact BAPIs SnapLogic calls</strong></td>
                                <td style="color:#e67e22; font-weight:bold;">Medium</td>
                                <td>Phase 0.4 captures this. Start with RFC_PING + Z_SNAP_IDOC_READ_COMPLETELY</td>
                            </tr>
                            <tr>
                                <td><strong>RFC function metadata is complex</strong></td>
                                <td style="color:#e67e22; font-weight:bold;">Medium</td>
                                <td>Phase 0.3 captures a real response as reference. Build metadata from actual data, not guesswork</td>
                            </tr>
                            <tr>
                                <td><strong>Account validation needs more than RFC_PING</strong></td>
                                <td style="color:#2980b9;">Low</td>
                                <td>Phase 3.3 tests early. If validation fails, add whatever extra RFC calls SnapLogic makes</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="info-box red">
                    <strong>Critical gate:</strong> Do NOT proceed past Phase 0 until PyRFC server mode is confirmed working. Everything depends on this. If it fails, use Option 1 (Mock at SnapLogic Layer) — which is already the recommended approach and works today with zero dependencies.
                </div>
            </div>

            <!-- Summary -->
            <div class="data-section">
                <h2>Plan Summary <span class="badge">Overview</span></h2>

                <div class="code-block">
<span class="label">Phase 0:</span>  Prerequisites &amp; Research       <span class="comment">← Validate feasibility (DO THIS FIRST)</span>
<span class="label">Phase 1:</span>  Project Structure                <span class="comment">← Scaffold folders (mirror Salesforce)</span>
<span class="label">Phase 2:</span>  In-Memory Database               <span class="comment">← sap_database = {}, reset_all()</span>
<span class="label">Phase 3:</span>  System Handlers                  <span class="comment">← RFC_PING, account validation ← <span class="success">FIRST MILESTONE</span></span>
<span class="label">Phase 4:</span>  IDoc Handlers                    <span class="comment">← CRUD: Create, Read, Update, Delete</span>
<span class="label">Phase 5:</span>  Function Metadata                <span class="comment">← Define RFC parameter types/structures</span>
<span class="label">Phase 6:</span>  Server Startup                   <span class="comment">← Dual-thread: PyRFC (3300) + Django (8080)</span>
<span class="label">Phase 7:</span>  Docker Setup                     <span class="comment">← Dockerfile + docker-compose</span>
<span class="label">Phase 8:</span>  Integration Test                 <span class="comment">← End-to-end: SnapLogic → Mock → Verify</span>
<span class="label">Phase 9:</span>  Robot Framework Integration      <span class="comment">← Test automation keywords + first test</span>
<span class="label">Phase 10:</span> Plugin Architecture              <span class="comment">← Future: unified SLIM Mock Service</span></div>

                <div class="info-box" style="background:#e8f5e9; border-left-color:#27ae60;">
                    <strong>Key principle:</strong> Every phase mirrors something already proven in the Salesforce mock server. We're not inventing new patterns &mdash; we're applying the same architecture (in-memory dict, CRUD handlers, admin reset, Docker, Robot Framework) to a different protocol (RFC instead of HTTP).
                </div>
            </div>
        </div>

    </div>

    <!-- ═══════════════════════════════════════════════════════════════
         JavaScript: Tab Navigation
         ═══════════════════════════════════════════════════════════════ -->
    <script>
        function showTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            const tabEl = document.getElementById(tabId);
            if (tabEl) tabEl.classList.add('active');
            const btnEl = document.querySelector(`[data-tab="${tabId}"]`);
            if (btnEl) btnEl.classList.add('active');
            history.replaceState(null, '', '#' + tabId);
        }

        window.addEventListener('load', () => {
            const hash = window.location.hash.substring(1);
            if (hash && document.getElementById(hash)) {
                showTab(hash);
            }
        });
    </script>
</body>
</html>
