'use strict';

/**
 * SOQL Query Parser
 * =================
 *
 * Parses Salesforce Object Query Language (SOQL) queries as generated by
 * SnapLogic Salesforce Read/SOQL snaps.
 *
 * SOQL is Salesforce's SQL-like query language. It looks like SQL but has
 * some differences (e.g., no JOIN, uses relationship names instead).
 *
 * Supported:
 *   SELECT fields FROM Object
 *   SELECT COUNT() FROM Object
 *   WHERE field = 'value' / != / > / >= / < / <= / LIKE / IN / NOT IN
 *   WHERE cond AND cond / OR cond
 *   ORDER BY field ASC/DESC [NULLS FIRST|LAST]
 *   LIMIT n / OFFSET n
 *
 * This module exports three functions:
 *   - parseSOQL(soql)          — Parses a SOQL string into a structured object
 *   - applyWhere(records, conditions) — Filters records based on WHERE conditions
 *   - applyOrderBy(records, orderBy)  — Sorts records based on ORDER BY clause
 */

// ═══════════════════════════════════════════════════════════════════════
// MAIN PARSER
// ═══════════════════════════════════════════════════════════════════════

/**
 * Parses a SOQL query string into a structured object.
 *
 * Takes a raw SOQL query string (as SnapLogic generates it) and extracts:
 *   - fields: Array of field names from SELECT clause
 *   - object: The Salesforce object name from FROM clause
 *   - where: Array of parsed conditions from WHERE clause (or null)
 *   - orderBy: { field, direction, nulls } from ORDER BY clause (or null)
 *   - limit: Number from LIMIT clause (or null)
 *   - offset: Number from OFFSET clause (or null)
 *   - isCount: true if this is a SELECT COUNT() query
 *
 * @param {string} soql - The SOQL query string to parse
 * @returns {Object} Parsed query object with fields, object, where, orderBy, limit, offset, isCount
 * @throws {Error} If SOQL is null, empty, or cannot be parsed
 *
 * @example
 *   // Simple SELECT query:
 *   parseSOQL('SELECT Id, Name, Type FROM Account');
 *   // Returns: {
 *   //   fields: ['Id', 'Name', 'Type'],
 *   //   object: 'Account',
 *   //   where: null, orderBy: null, limit: null, offset: null, isCount: false
 *   // }
 *
 * @example
 *   // SELECT with WHERE clause:
 *   parseSOQL("SELECT Id, Name FROM Account WHERE Type = 'Customer'");
 *   // Returns: {
 *   //   fields: ['Id', 'Name'],
 *   //   object: 'Account',
 *   //   where: [{ field: 'Type', operator: '=', value: 'Customer', logical: null }],
 *   //   orderBy: null, limit: null, offset: null, isCount: false
 *   // }
 *
 * @example
 *   // SELECT with WHERE + AND:
 *   parseSOQL("SELECT Id FROM Contact WHERE LastName = 'Smith' AND Email != null");
 *   // Returns: {
 *   //   fields: ['Id'],
 *   //   object: 'Contact',
 *   //   where: [
 *   //     { field: 'LastName', operator: '=', value: 'Smith', logical: null },
 *   //     { field: 'Email', operator: '!=', value: null, logical: 'AND' }
 *   //   ],
 *   //   ...
 *   // }
 *
 * @example
 *   // SELECT with ORDER BY and LIMIT:
 *   parseSOQL('SELECT Id, Name FROM Account ORDER BY Name ASC LIMIT 10');
 *   // Returns: {
 *   //   fields: ['Id', 'Name'],
 *   //   object: 'Account',
 *   //   where: null,
 *   //   orderBy: { field: 'Name', direction: 'ASC', nulls: null },
 *   //   limit: 10, offset: null, isCount: false
 *   // }
 *
 * @example
 *   // COUNT() query:
 *   parseSOQL('SELECT COUNT() FROM Lead');
 *   // Returns: {
 *   //   fields: [], object: 'Lead',
 *   //   where: null, orderBy: null, limit: null, offset: null,
 *   //   isCount: true
 *   // }
 *
 * @example
 *   // WHERE with IN operator:
 *   parseSOQL("SELECT Id FROM Account WHERE Type IN ('Customer', 'Partner')");
 *   // Returns: {
 *   //   ...
 *   //   where: [{ field: 'Type', operator: 'IN', value: ['Customer', 'Partner'], logical: null }]
 *   // }
 *
 * @example
 *   // WHERE with LIKE operator (wildcard search):
 *   parseSOQL("SELECT Id, Name FROM Account WHERE Name LIKE '%Corp%'");
 *   // Returns: {
 *   //   ...
 *   //   where: [{ field: 'Name', operator: 'LIKE', value: '%Corp%', logical: null }]
 *   // }
 */
function parseSOQL(soql) {
  if (!soql || typeof soql !== 'string') {
    throw new Error('SOQL query is required');
  }

  const normalized = soql.trim().replace(/\s+/g, ' ');
  const result = { fields: [], object: null, where: null, orderBy: null, limit: null, offset: null, isCount: false };

  // Check for COUNT()
  const countMatch = normalized.match(/^SELECT\s+COUNT\(\)\s+FROM\s+(\w+)/i);
  if (countMatch) {
    result.isCount = true;
    result.object = countMatch[1];
    parseWhereClause(normalized, result);
    return result;
  }

  // Parse SELECT fields
  const selectMatch = normalized.match(/^SELECT\s+(.+?)\s+FROM\s+(\w+)/i);
  if (!selectMatch) {
    throw new Error(`Malformed SOQL: Cannot parse SELECT...FROM: ${soql}`);
  }

  result.fields = selectMatch[1].split(',').map(f => f.trim()).filter(f => f);
  result.object = selectMatch[2];

  parseWhereClause(normalized, result);
  parseOrderBy(normalized, result);
  parseLimit(normalized, result);
  parseOffset(normalized, result);

  return result;
}

// ═══════════════════════════════════════════════════════════════════════
// WHERE CLAUSE PARSING (Internal helpers — not exported)
// ═══════════════════════════════════════════════════════════════════════

/**
 * Extracts and parses the WHERE clause from the SOQL string.
 * Populates result.where with an array of condition objects.
 *
 * Internal function — called by parseSOQL().
 *
 * @param {string} soql - The normalized SOQL string
 * @param {Object} result - The result object to populate with where conditions
 *
 * @example
 *   // Input SOQL: "SELECT Id FROM Account WHERE Type = 'Customer'"
 *   // After parseWhereClause, result.where becomes:
 *   // [{ field: 'Type', operator: '=', value: 'Customer', logical: null }]
 */
function parseWhereClause(soql, result) {
  const whereMatch = soql.match(/\bWHERE\s+(.+?)(?:\s+ORDER\s+BY|\s+LIMIT|\s+OFFSET|$)/i);
  if (!whereMatch) return;
  result.where = parseConditions(whereMatch[1].trim());
}

/**
 * Parses a WHERE clause string into an array of condition objects.
 * Handles AND/OR logical operators between conditions.
 *
 * Internal function — called by parseWhereClause().
 *
 * @param {string} condStr - The WHERE clause content (without the "WHERE" keyword)
 * @returns {Object[]} Array of condition objects: { field, operator, value, logical }
 *
 * @example
 *   // Single condition:
 *   parseConditions("Type = 'Customer'");
 *   // Returns: [{ field: 'Type', operator: '=', value: 'Customer', logical: null }]
 *
 * @example
 *   // Multiple conditions with AND:
 *   parseConditions("Type = 'Customer' AND Status = 'Active'");
 *   // Returns: [
 *   //   { field: 'Type', operator: '=', value: 'Customer', logical: null },
 *   //   { field: 'Status', operator: '=', value: 'Active', logical: 'AND' }
 *   // ]
 */
function parseConditions(condStr) {
  const conditions = [];
  const parts = splitByLogicalOperators(condStr);

  for (const part of parts) {
    const condition = parseSingleCondition(part.condition);
    if (condition) {
      condition.logical = part.logical;
      conditions.push(condition);
    }
  }
  return conditions;
}

/**
 * Splits a WHERE clause string by AND/OR operators, respecting quoted strings.
 * Handles cases where AND/OR might appear inside string literals (e.g., "Rock AND Roll").
 *
 * Internal function — called by parseConditions().
 *
 * @param {string} str - The WHERE clause content to split
 * @returns {Object[]} Array of { condition, logical } objects
 *
 * @example
 *   splitByLogicalOperators("Type = 'Customer' AND Name LIKE '%Corp%'");
 *   // Returns: [
 *   //   { condition: "Type = 'Customer'", logical: null },
 *   //   { condition: "Name LIKE '%Corp%'", logical: 'AND' }
 *   // ]
 *
 * @example
 *   splitByLogicalOperators("Status = 'Active' OR Status = 'Pending'");
 *   // Returns: [
 *   //   { condition: "Status = 'Active'", logical: null },
 *   //   { condition: "Status = 'Pending'", logical: 'OR' }
 *   // ]
 */
function splitByLogicalOperators(str) {
  const parts = [];
  let current = '';
  let inQuote = false;
  const tokens = str.split(/\s+/);
  let logical = null;

  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    const quoteCount = (token.match(/'/g) || []).length;
    if (quoteCount % 2 !== 0) inQuote = !inQuote;

    if (!inQuote && (token.toUpperCase() === 'AND' || token.toUpperCase() === 'OR')) {
      if (current.trim()) {
        parts.push({ condition: current.trim(), logical });
      }
      logical = token.toUpperCase();
      current = '';
    } else {
      current += (current ? ' ' : '') + token;
    }
  }

  if (current.trim()) {
    parts.push({ condition: current.trim(), logical });
  }
  return parts;
}

/**
 * Parses a single WHERE condition into a structured object.
 *
 * Supports these operators:
 *   - Comparison: = != <> > >= < <=
 *   - Pattern: LIKE (with % and _ wildcards)
 *   - Set: IN, NOT IN
 *
 * Automatically converts value types:
 *   - 'value' → string (strips quotes)
 *   - 42      → number
 *   - true    → boolean
 *   - null    → null
 *
 * Internal function — called by parseConditions().
 *
 * @param {string} condStr - A single condition string (e.g., "Name = 'Acme'")
 * @returns {Object|null} Condition object { field, operator, value } or null if unparseable
 *
 * @example
 *   // Equality:
 *   parseSingleCondition("Type = 'Customer'");
 *   // Returns: { field: 'Type', operator: '=', value: 'Customer' }
 *
 * @example
 *   // Not-equals (both != and <> are supported):
 *   parseSingleCondition("Status != 'Closed'");
 *   // Returns: { field: 'Status', operator: '!=', value: 'Closed' }
 *
 * @example
 *   // Numeric comparison:
 *   parseSingleCondition("Amount > 1000");
 *   // Returns: { field: 'Amount', operator: '>', value: 1000 }
 *
 * @example
 *   // LIKE with wildcards:
 *   parseSingleCondition("Name LIKE '%Corp%'");
 *   // Returns: { field: 'Name', operator: 'LIKE', value: '%Corp%' }
 *
 * @example
 *   // IN operator:
 *   parseSingleCondition("Type IN ('Customer', 'Partner')");
 *   // Returns: { field: 'Type', operator: 'IN', value: ['Customer', 'Partner'] }
 *
 * @example
 *   // NULL comparison:
 *   parseSingleCondition("Email = null");
 *   // Returns: { field: 'Email', operator: '=', value: null }
 *
 * @example
 *   // Boolean comparison:
 *   parseSingleCondition("IsActive = true");
 *   // Returns: { field: 'IsActive', operator: '=', value: true }
 */
function parseSingleCondition(condStr) {
  // IN operator: field IN ('val1', 'val2')
  const inMatch = condStr.match(/^(\w+)\s+IN\s*\((.+)\)/i);
  if (inMatch) {
    const values = inMatch[2].split(',').map(v => v.trim().replace(/^'|'$/g, ''));
    return { field: inMatch[1], operator: 'IN', value: values };
  }

  // NOT IN operator
  const notInMatch = condStr.match(/^(\w+)\s+NOT\s+IN\s*\((.+)\)/i);
  if (notInMatch) {
    const values = notInMatch[2].split(',').map(v => v.trim().replace(/^'|'$/g, ''));
    return { field: notInMatch[1], operator: 'NOT IN', value: values };
  }

  // LIKE operator: field LIKE '%pattern%'
  const likeMatch = condStr.match(/^(\w+)\s+LIKE\s+'(.+)'/i);
  if (likeMatch) {
    return { field: likeMatch[1], operator: 'LIKE', value: likeMatch[2] };
  }

  // Comparison operators: =, !=, <>, >=, <=, >, <
  const compMatch = condStr.match(/^(\w+)\s*(!=|<>|>=|<=|>|<|=)\s*(.+)$/);
  if (compMatch) {
    let value = compMatch[3].trim();
    // Auto-detect and convert value types
    if (value.startsWith("'") && value.endsWith("'")) {
      value = value.slice(1, -1);         // String: strip quotes
    } else if (!isNaN(value)) {
      value = Number(value);               // Number: convert to numeric
    } else if (value.toLowerCase() === 'true') {
      value = true;                        // Boolean: true
    } else if (value.toLowerCase() === 'false') {
      value = false;                       // Boolean: false
    } else if (value.toLowerCase() === 'null') {
      value = null;                        // Null
    }
    const operator = compMatch[2] === '<>' ? '!=' : compMatch[2];  // Normalize <> to !=
    return { field: compMatch[1], operator, value };
  }

  return null;
}

// ═══════════════════════════════════════════════════════════════════════
// ORDER BY, LIMIT, OFFSET PARSERS (Internal helpers)
// ═══════════════════════════════════════════════════════════════════════

/**
 * Extracts the ORDER BY clause from the SOQL string.
 * Populates result.orderBy with { field, direction }.
 *
 * Internal function — called by parseSOQL().
 *
 * @param {string} soql - The normalized SOQL string
 * @param {Object} result - The result object to populate
 *
 * @example
 *   // Input: "SELECT Id FROM Account ORDER BY Name ASC"
 *   // After: result.orderBy = { field: 'Name', direction: 'ASC', nulls: null }
 *
 * @example
 *   // Default direction is ASC if not specified:
 *   // Input: "SELECT Id FROM Account ORDER BY Name"
 *   // After: result.orderBy = { field: 'Name', direction: 'ASC', nulls: null }
 *
 * @example
 *   // NULLS FIRST/LAST support:
 *   // Input: "SELECT Id FROM Account ORDER BY Name DESC NULLS LAST"
 *   // After: result.orderBy = { field: 'Name', direction: 'DESC', nulls: 'LAST' }
 */
function parseOrderBy(soql, result) {
  const orderMatch = soql.match(/\bORDER\s+BY\s+(\w+)(?:\s+(ASC|DESC))?(?:\s+NULLS\s+(FIRST|LAST))?/i);
  if (orderMatch) {
    result.orderBy = {
      field: orderMatch[1],
      direction: (orderMatch[2] || 'ASC').toUpperCase(),
      nulls: orderMatch[3] ? orderMatch[3].toUpperCase() : null
    };
  }
}

/**
 * Extracts the LIMIT clause from the SOQL string.
 * Populates result.limit with the numeric value.
 *
 * Internal function — called by parseSOQL().
 *
 * @param {string} soql - The normalized SOQL string
 * @param {Object} result - The result object to populate
 *
 * @example
 *   // Input: "SELECT Id FROM Account LIMIT 10"
 *   // After: result.limit = 10
 */
function parseLimit(soql, result) {
  const limitMatch = soql.match(/\bLIMIT\s+(\d+)/i);
  if (limitMatch) result.limit = parseInt(limitMatch[1], 10);
}

/**
 * Extracts the OFFSET clause from the SOQL string.
 * Populates result.offset with the numeric value.
 * Used for pagination in SOQL queries.
 *
 * Internal function — called by parseSOQL().
 *
 * @param {string} soql - The normalized SOQL string
 * @param {Object} result - The result object to populate
 *
 * @example
 *   // Input: "SELECT Id FROM Account LIMIT 10 OFFSET 20"
 *   // After: result.offset = 20
 */
function parseOffset(soql, result) {
  const offsetMatch = soql.match(/\bOFFSET\s+(\d+)/i);
  if (offsetMatch) result.offset = parseInt(offsetMatch[1], 10);
}

// ═══════════════════════════════════════════════════════════════════════
// QUERY EXECUTION HELPERS (Exported)
// ═══════════════════════════════════════════════════════════════════════

/**
 * Filters an array of records based on parsed WHERE conditions.
 *
 * Each condition has: { field, operator, value, logical }
 * - The first condition's logical is null (it's the starting condition)
 * - Subsequent conditions have logical = 'AND' or 'OR'
 *
 * Evaluation is left-to-right (no operator precedence — matches most SOQL usage).
 *
 * @param {Object[]} records - Array of record objects to filter
 * @param {Object[]} conditions - Array of condition objects from parseSOQL().where
 * @returns {Object[]} Filtered array of records that match all conditions
 *
 * @example
 *   // Filter accounts where Type = 'Customer':
 *   const conditions = [{ field: 'Type', operator: '=', value: 'Customer', logical: null }];
 *   const allAccounts = [
 *     { Id: '001ABC', Name: 'Acme', Type: 'Customer' },
 *     { Id: '001DEF', Name: 'Beta', Type: 'Partner' },
 *     { Id: '001GHI', Name: 'Gamma', Type: 'Customer' }
 *   ];
 *   applyWhere(allAccounts, conditions);
 *   // Returns: [
 *   //   { Id: '001ABC', Name: 'Acme', Type: 'Customer' },
 *   //   { Id: '001GHI', Name: 'Gamma', Type: 'Customer' }
 *   // ]
 *
 * @example
 *   // Filter with AND:
 *   const conditions = [
 *     { field: 'Type', operator: '=', value: 'Customer', logical: null },
 *     { field: 'Name', operator: 'LIKE', value: '%Corp%', logical: 'AND' }
 *   ];
 *   applyWhere(records, conditions);
 *   // Returns only records where Type='Customer' AND Name contains 'Corp'
 *
 * @example
 *   // Empty/null conditions returns all records (no filtering):
 *   applyWhere(records, []);
 *   // Returns: all records unchanged
 *   applyWhere(records, null);
 *   // Returns: all records unchanged
 */
function applyWhere(records, conditions) {
  if (!conditions || conditions.length === 0) return records;

  return records.filter(record => {
    let result = evaluateCondition(record, conditions[0]);
    for (let i = 1; i < conditions.length; i++) {
      const cond = conditions[i];
      const condResult = evaluateCondition(record, cond);
      if (cond.logical === 'AND') result = result && condResult;
      else if (cond.logical === 'OR') result = result || condResult;
    }
    return result;
  });
}

/**
 * Evaluates a single condition against a record.
 *
 * Supports these operators:
 *   =, !=   — string comparison (converts both sides to string)
 *   >, >=, <, <= — numeric comparison (converts both sides to number)
 *   LIKE    — pattern matching (% = any chars, _ = single char)
 *   IN      — checks if record value is in the values array
 *   NOT IN  — checks if record value is NOT in the values array
 *
 * Internal function — called by applyWhere().
 *
 * @param {Object} record - A single record object
 * @param {Object} condition - A condition object { field, operator, value }
 * @returns {boolean} true if the record matches the condition
 *
 * @example
 *   evaluateCondition({ Name: 'Acme Corp' }, { field: 'Name', operator: '=', value: 'Acme Corp' });
 *   // Returns: true
 *
 * @example
 *   evaluateCondition({ Name: 'Acme Corp' }, { field: 'Name', operator: 'LIKE', value: '%Corp%' });
 *   // Returns: true (% matches any characters)
 *
 * @example
 *   evaluateCondition({ Amount: 5000 }, { field: 'Amount', operator: '>', value: 1000 });
 *   // Returns: true
 */
function evaluateCondition(record, condition) {
  const recordValue = record[condition.field];

  switch (condition.operator) {
    case '=':  return String(recordValue) === String(condition.value);
    case '!=': return String(recordValue) !== String(condition.value);
    case '>':  return Number(recordValue) > Number(condition.value);
    case '>=': return Number(recordValue) >= Number(condition.value);
    case '<':  return Number(recordValue) < Number(condition.value);
    case '<=': return Number(recordValue) <= Number(condition.value);
    case 'LIKE': {
      // Convert SOQL LIKE pattern to regex:
      //   % → .* (matches any number of characters)
      //   _ → .  (matches exactly one character)
      if (recordValue === null || recordValue === undefined) return false;
      const pattern = condition.value.replace(/%/g, '.*').replace(/_/g, '.');
      return new RegExp(`^${pattern}$`, 'i').test(String(recordValue));
    }
    case 'IN':     return condition.value.includes(String(recordValue));
    case 'NOT IN': return !condition.value.includes(String(recordValue));
    default: return true;
  }
}

/**
 * Sorts an array of records based on the ORDER BY clause.
 *
 * Creates a NEW sorted array (does not mutate the original).
 * Handles null/undefined values by pushing them to the end.
 * Supports both string (lexicographic) and number sorting automatically.
 *
 * @param {Object[]} records - Array of record objects to sort
 * @param {Object} orderBy - Order specification: { field: string, direction: 'ASC'|'DESC', nulls: 'FIRST'|'LAST'|null }
 * @returns {Object[]} New sorted array of records
 *
 * @example
 *   // Sort accounts by Name ascending:
 *   const records = [
 *     { Id: '001C', Name: 'Charlie' },
 *     { Id: '001A', Name: 'Alice' },
 *     { Id: '001B', Name: 'Bob' }
 *   ];
 *   applyOrderBy(records, { field: 'Name', direction: 'ASC', nulls: null });
 *   // Returns: [
 *   //   { Id: '001A', Name: 'Alice' },
 *   //   { Id: '001B', Name: 'Bob' },
 *   //   { Id: '001C', Name: 'Charlie' }
 *   // ]
 *
 * @example
 *   // Sort by Amount descending (numeric sort):
 *   applyOrderBy(records, { field: 'Amount', direction: 'DESC', nulls: null });
 *   // Returns records sorted from highest to lowest Amount
 *
 * @example
 *   // NULLS FIRST: push null values to the beginning:
 *   applyOrderBy(records, { field: 'Name', direction: 'ASC', nulls: 'FIRST' });
 *   // Returns records with null Names first, then sorted ascending
 *
 * @example
 *   // NULLS LAST: push null values to the end:
 *   applyOrderBy(records, { field: 'Name', direction: 'DESC', nulls: 'LAST' });
 *   // Returns records sorted descending, with null Names at the end
 *
 * @example
 *   // Null orderBy returns records unchanged:
 *   applyOrderBy(records, null);
 *   // Returns: original records array (no sorting)
 */
function applyOrderBy(records, orderBy) {
  if (!orderBy) return records;

  // Determine null positioning:
  //   - If NULLS FIRST is specified, nulls go to the beginning (-1 for a null, 1 for b null)
  //   - If NULLS LAST is specified, nulls go to the end (1 for a null, -1 for b null)
  //   - Default (no NULLS clause): nulls go to the end (same as NULLS LAST)
  const nullsFirst = orderBy.nulls === 'FIRST';

  return [...records].sort((a, b) => {
    const aVal = a[orderBy.field];
    const bVal = b[orderBy.field];
    if (aVal === bVal) return 0;
    if (aVal === null || aVal === undefined) return nullsFirst ? -1 : 1;
    if (bVal === null || bVal === undefined) return nullsFirst ? 1 : -1;
    const comparison = typeof aVal === 'number' ? aVal - bVal : String(aVal).localeCompare(String(bVal));
    return orderBy.direction === 'DESC' ? -comparison : comparison;
  });
}

module.exports = { parseSOQL, applyWhere, applyOrderBy };
