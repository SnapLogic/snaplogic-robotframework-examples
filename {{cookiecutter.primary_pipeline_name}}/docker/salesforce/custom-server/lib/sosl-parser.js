'use strict';

/**
 * SOSL Query Parser
 * =================
 *
 * Parses Salesforce Object Search Language (SOSL) queries as generated by
 * SnapLogic Salesforce SOSL snap.
 *
 * SOSL is Salesforce's cross-object search language. Unlike SOQL (which queries
 * a single object), SOSL searches across multiple objects simultaneously.
 *
 * Syntax:
 *   FIND {searchTerm} [IN scope] RETURNING Object1(Field1, Field2 [WHERE cond] [LIMIT n]), Object2(...)
 *
 * Supported:
 *   FIND {searchTerm}
 *   IN ALL FIELDS / IN NAME FIELDS / IN EMAIL FIELDS / IN PHONE FIELDS
 *   RETURNING Object(Field1, Field2)
 *   RETURNING Object(Field1 WHERE Field2 = 'value')
 *   RETURNING Object(Field1 LIMIT 10)
 *   Multiple RETURNING objects separated by commas
 *
 * This module exports:
 *   - parseSOSL(sosl) â€” Parses a SOSL string into a structured object
 */

/**
 * Parses a SOSL query string into a structured object.
 *
 * @param {string} sosl - The SOSL query string to parse
 * @returns {Object} Parsed query:
 *   {
 *     searchTerm: string,
 *     scope: string ('ALL'|'NAME'|'EMAIL'|'PHONE'),
 *     returning: [
 *       { object: string, fields: string[], where: string|null, limit: number|null }
 *     ]
 *   }
 * @throws {Error} If SOSL is null, empty, or cannot be parsed
 *
 * @example
 *   parseSOSL('FIND {Acme} RETURNING Account(Id, Name)');
 *   // Returns: {
 *   //   searchTerm: 'Acme',
 *   //   scope: 'ALL',
 *   //   returning: [{ object: 'Account', fields: ['Id', 'Name'], where: null, limit: null }]
 *   // }
 *
 * @example
 *   parseSOSL('FIND {test} IN NAME FIELDS RETURNING Account(Id, Name), Contact(Id, Email)');
 *   // Returns: {
 *   //   searchTerm: 'test',
 *   //   scope: 'NAME',
 *   //   returning: [
 *   //     { object: 'Account', fields: ['Id', 'Name'], where: null, limit: null },
 *   //     { object: 'Contact', fields: ['Id', 'Email'], where: null, limit: null }
 *   //   ]
 *   // }
 *
 * @example
 *   parseSOSL("FIND {Corp} RETURNING Account(Id, Name WHERE Type = 'Customer' LIMIT 5)");
 *   // Returns: {
 *   //   searchTerm: 'Corp',
 *   //   scope: 'ALL',
 *   //   returning: [{
 *   //     object: 'Account',
 *   //     fields: ['Id', 'Name'],
 *   //     where: "Type = 'Customer'",
 *   //     limit: 5
 *   //   }]
 *   // }
 */
function parseSOSL(sosl) {
  if (!sosl || typeof sosl !== 'string') {
    throw new Error('SOSL query is required');
  }

  const normalized = sosl.trim().replace(/\s+/g, ' ');
  const result = { searchTerm: null, scope: 'ALL', returning: [] };

  // Parse FIND clause: FIND {searchTerm}
  const findMatch = normalized.match(/^FIND\s+\{([^}]+)\}/i);
  if (!findMatch) {
    throw new Error(`Malformed SOSL: Cannot parse FIND clause: ${sosl}`);
  }
  result.searchTerm = findMatch[1].trim();

  // Parse optional IN clause: IN ALL FIELDS / IN NAME FIELDS / etc.
  const inMatch = normalized.match(/\bIN\s+(ALL|NAME|EMAIL|PHONE|SIDEBAR)\s+FIELDS\b/i);
  if (inMatch) {
    result.scope = inMatch[1].toUpperCase();
  }

  // Parse RETURNING clause
  const returningMatch = normalized.match(/\bRETURNING\s+(.+)$/i);
  if (!returningMatch) {
    throw new Error(`Malformed SOSL: Cannot parse RETURNING clause: ${sosl}`);
  }

  const returningStr = returningMatch[1].trim();
  result.returning = parseReturningClause(returningStr);

  return result;
}

/**
 * Parses the RETURNING clause into an array of object specifications.
 *
 * Handles comma-separated objects with parenthesized field lists:
 *   Account(Id, Name), Contact(Id, Email WHERE LastName = 'Smith' LIMIT 5)
 *
 * @param {string} str - The RETURNING clause content (without "RETURNING" keyword)
 * @returns {Object[]} Array of { object, fields, where, limit }
 */
function parseReturningClause(str) {
  const objects = [];

  // Split by top-level commas (not inside parentheses)
  const parts = splitTopLevelCommas(str);

  for (const part of parts) {
    const trimmed = part.trim();
    if (!trimmed) continue;

    // Match: ObjectName(fields...) or just ObjectName
    const objMatch = trimmed.match(/^(\w+)(?:\((.+)\))?$/);
    if (!objMatch) continue;

    const spec = {
      object: objMatch[1],
      fields: [],
      where: null,
      limit: null
    };

    if (objMatch[2]) {
      const inner = objMatch[2].trim();
      parseReturningFields(inner, spec);
    }

    objects.push(spec);
  }

  return objects;
}

/**
 * Splits a string by commas that are NOT inside parentheses.
 * This handles: Account(Id, Name), Contact(Id, Email)
 *
 * @param {string} str - The string to split
 * @returns {string[]} Array of top-level comma-separated parts
 */
function splitTopLevelCommas(str) {
  const parts = [];
  let current = '';
  let depth = 0;

  for (let i = 0; i < str.length; i++) {
    const ch = str[i];
    if (ch === '(') depth++;
    else if (ch === ')') depth--;
    else if (ch === ',' && depth === 0) {
      parts.push(current);
      current = '';
      continue;
    }
    current += ch;
  }
  if (current.trim()) parts.push(current);
  return parts;
}

/**
 * Parses the inner content of a RETURNING object's parentheses.
 * Extracts fields, WHERE clause, and LIMIT.
 *
 * Input examples:
 *   "Id, Name"
 *   "Id, Name WHERE Type = 'Customer'"
 *   "Id, Name WHERE Type = 'Customer' LIMIT 5"
 *   "Id, Name LIMIT 10"
 *
 * @param {string} inner - The content inside parentheses
 * @param {Object} spec - The object spec to populate with fields/where/limit
 */
function parseReturningFields(inner, spec) {
  // Extract LIMIT clause (at the end)
  let remaining = inner;
  const limitMatch = remaining.match(/\bLIMIT\s+(\d+)\s*$/i);
  if (limitMatch) {
    spec.limit = parseInt(limitMatch[1], 10);
    remaining = remaining.substring(0, limitMatch.index).trim();
  }

  // Extract WHERE clause
  const whereMatch = remaining.match(/\bWHERE\s+(.+)$/i);
  if (whereMatch) {
    spec.where = whereMatch[1].trim();
    remaining = remaining.substring(0, whereMatch.index).trim();
  }

  // Remaining content is the field list
  spec.fields = remaining.split(',').map(f => f.trim()).filter(f => f);
}

/**
 * Searches records for a search term in string fields.
 *
 * For "ALL FIELDS" scope, searches all string-type field values.
 * For "NAME FIELDS" scope, searches Name, FirstName, LastName fields.
 * The search is case-insensitive and matches partial strings.
 *
 * @param {Object[]} records - Array of records to search
 * @param {string} searchTerm - The term to search for
 * @param {string} scope - Search scope: 'ALL', 'NAME', 'EMAIL', 'PHONE'
 * @returns {Object[]} Records that match the search term
 *
 * @example
 *   searchRecords(
 *     [{ Id: '001A', Name: 'Acme Corp' }, { Id: '001B', Name: 'Beta Inc' }],
 *     'Acme',
 *     'ALL'
 *   );
 *   // Returns: [{ Id: '001A', Name: 'Acme Corp' }]
 */
function searchRecords(records, searchTerm, scope) {
  const term = searchTerm.toLowerCase();

  // Determine which fields to search based on scope
  const scopeFields = {
    NAME: ['Name', 'FirstName', 'LastName', 'Title', 'Subject'],
    EMAIL: ['Email', 'PersonEmail'],
    PHONE: ['Phone', 'MobilePhone', 'Fax', 'HomePhone']
  };

  return records.filter(record => {
    const fieldsToSearch = scope === 'ALL'
      ? Object.keys(record)
      : (scopeFields[scope] || Object.keys(record));

    return fieldsToSearch.some(field => {
      const value = record[field];
      if (value === null || value === undefined) return false;
      if (typeof value !== 'string' && typeof value !== 'number') return false;
      return String(value).toLowerCase().includes(term);
    });
  });
}

module.exports = { parseSOSL, searchRecords };
