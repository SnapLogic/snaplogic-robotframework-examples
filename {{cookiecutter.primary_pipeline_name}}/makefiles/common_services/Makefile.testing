# =============================================================================
# Testing & Test Execution Targets
# =============================================================================
# This file contains all Robot Framework test execution related targets
# including single tests, parallel execution, and test reporting
# =============================================================================

.PHONY: robot-run-tests robot-run-all-tests robot-run-tests-no-gp slack-notify upload-test-results upload-test-results-cli sl-export-assets sl-import-assets sl-export-assets-full sl-import-assets-full

# Include common configuration
include makefiles/common_services/Makefile.common

# =============================================================================
# üß™ Run Robot Framework tests with optional tags
#   ‚Üí usage: make robot-run-tests TAGS="oracle,minio" PROJECT_SPACE_SETUP=True
#   ‚Üí usage with ENV override: make robot-run-tests TAGS="oracle" ENV=.env.stage
# =============================================================================
robot-run-tests: check-env
	@echo "üß™ Starting Robot Framework tests..."
	@echo "‚ÑπÔ∏è Tags: $(TAGS)"
	$(eval INCLUDES=$(foreach arg,$(TAGS),--include $(arg)))
	$(eval PROJECT_SPACE_SETUP_VAL=$(if $(PROJECT_SPACE_SETUP),$(PROJECT_SPACE_SETUP),False))
	$(eval ENV_OVERRIDE_VAR=$(if $(ENV),--variable ENV_OVERRIDE_FILE:/app/$(notdir $(ENV)),))
	@if [ -n "$(ENV)" ]; then \
		echo "‚ÑπÔ∏è ENV override: $(ENV) -> copying to container..."; \
		docker cp "$(ENV)" snaplogic-test-example-tools-container:/app/$(notdir $(ENV)); \
	fi
	@$(DOCKER_COMPOSE) exec -w /app/test tools robot \
		-G $(DATE) \
		--timestampoutputs \
		--variable PROJECT_SPACE_SETUP:$(PROJECT_SPACE_SETUP_VAL) \
		--variable TAGS:"$(TAGS)" \
		$(ENV_OVERRIDE_VAR) \
		$(INCLUDES) \
		--outputdir robot_output suite/ && \
	echo "‚úÖ Tests completed successfully!" || \
	{ echo "‚ùå Some tests failed. Check the logs for details." }

# =============================================================================
# üß™ End-to-End Robot Test Workflow (including environment setup)
#  ‚Üí usage if user want to delete the projectspace(if exists) and create a clean project space add the flag PROJECT_SPACE_SETUP=True
#.   make robot-run-all-tests TAGS="oracle,minio" PROJECT_SPACE_SETUP=True
# =============================================================================
robot-run-all-tests: check-env
	@PROJECT_SPACE_SETUP_ACTUAL=$${PROJECT_SPACE_SETUP:-False}; \
	echo ":========== [Phase 1] Create project space and create plex inside project space =========="; \
	if [ "$$PROJECT_SPACE_SETUP_ACTUAL" = "True" ]; then \
		echo ":========= [Phase 1] Running createplex tests ========================================="; \
		$(MAKE) robot-run-tests TAGS="createplex" PROJECT_SPACE_SETUP=True || { \
			echo "‚ùå createplex test failed, checking if error is due to active Snaplex nodes..."; \
			if grep -rq "cannot be deleted while it contains active nodes" test/robot_output/log-*.html 2>/dev/null; then \
				echo "üõë Active Groundplex nodes detected ‚Äî killing Groundplex and retrying to create project space and plex..."; \
				$(MAKE) stop-groundplex; \
				echo "‚è≥ Waiting 60 seconds for nodes to deregister from SnapLogic Cloud..."; \
				sleep 60; \
				$(MAKE) robot-run-tests TAGS="createplex" PROJECT_SPACE_SETUP=True || exit 1; \
			else \
				echo "‚ùå createplex test failed for a different reason."; \
				exit 1; \
			fi; \
		}; \
	else \
		echo "‚è© Skipping createplex setup (PROJECT_SPACE_SETUP is not True)"; \
		echo ":========== [Phase 1.1] Verifying if project space exists =========="; \
		$(MAKE) robot-run-tests TAGS="verify_project_space_exists" PROJECT_SPACE_SETUP=False || exit 1; \
	fi; \
	\
	echo ":========== [Phase 2] Computing and starting containers using COMPOSE_PROFILES... =========="; \
	$(MAKE) launch-groundplex; \
	\
	echo ":========== [Phase 2.1] Setting permissions for test data directories (Travis only) =========="; \
	if [ "$$TRAVIS" = "true" ]; then \
		chmod +x ./travis_scripts/set_travis_permissions.sh; \
		./travis_scripts/set_travis_permissions.sh || echo "Warning: Could not set all permissions"; \
	else \
		echo "‚ÑπÔ∏è Skipping set_travis_permissions (not running on Travis CI)"; \
	fi; \
	\
	echo ":========== [Phase 3] Running user-defined robot tests... =========="; \
	$(MAKE) robot-run-tests TAGS="$(TAGS)" PROJECT_SPACE_SETUP=False


# =============================================================================
# üõë Kill Snaplex JCC and shutdown groundplex container (with retries)
# =============================================================================
stop-groundplex:
	@echo "üõë Attempting to stop JCC inside snaplogic-groundplex container..."
	docker exec snaplogic-groundplex /bin/bash -c "cd /opt/snaplogic/bin && sh jcc.sh stop" || true

	@echo "üîÅ Waiting for JCC to fully shut down (up to 20 attempts, 10s interval)..."
	@attempt=1; \
	while [ $$attempt -le 20 ]; do \
		echo "‚è±Ô∏è Attempt $$attempt..."; \
		container_status=$$(docker inspect -f '{{.State.Status}}' snaplogic-groundplex 2>/dev/null); \
		if [ "$$container_status" != "running" ]; then \
			echo "‚úÖ Container is already stopped."; \
			break; \
		else \
			status=$$(docker exec snaplogic-groundplex /bin/bash -c "cd /opt/snaplogic/bin && sh jcc.sh status" 2>&1); \
			echo "üîç JCC Status: $$status"; \
			echo "$$status" | grep -q "PID file not found" && break; \
			echo "‚åõ JCC still shutting down. Retrying in 10s..."; \
		fi; \
		sleep 10; \
		attempt=$$((attempt + 1)); \
	done; \
	if [ $$attempt -gt 20 ]; then \
		echo "‚ùå JCC failed to stop cleanly after 20 attempts."; \
		exit 1; \
	else \
		echo "‚úÖ JCC shutdown confirmed."; \
	fi

	@echo "üßπ Bringing down container using Docker Compose profile 'gp'..."
	$(DOCKER_COMPOSE) --profile gp down --remove-orphans

	@echo "‚úÖ Groundplex successfully stopped and cleaned up."

# =============================================================================
# üß™ Robot Test Workflow WITHOUT Groundplex Launch
#  ‚Üí Use this when Groundplex is already running or not needed for your tests
#  ‚Üí usage: make robot-run-tests-no-gp TAGS="oracle,minio" PROJECT_SPACE_SETUP=True
# =============================================================================
# =============================================================================
# üß™ Robot Test Workflow WITHOUT Groundplex Launch
#  ‚Üí Use this when Groundplex is already running or not needed for your tests
#  ‚Üí When PROJECT_SPACE_SETUP=True: Creates only project space (no plex)
#  ‚Üí usage: make robot-run-tests-no-gp TAGS="oracle,minio" PROJECT_SPACE_SETUP=True
# =============================================================================

robot-run-tests-no-gp: check-env
	@PROJECT_SPACE_SETUP_ACTUAL=$${PROJECT_SPACE_SETUP:-False}; \
	echo ":========== [Phase 1] Create project space (No Plex created) =========="; \
	if [ "$$PROJECT_SPACE_SETUP_ACTUAL" = "True" ]; then \
		echo ":========= [Phase 1] Creating Project Space ========================================="; \
		$(MAKE) robot-run-tests TAGS="verify_project_space_exists" PROJECT_SPACE_SETUP=True || { \
			echo "‚ùå Project space creation failed, checking if error is due to active Snaplex nodes..."; \
			if grep -rq "cannot be deleted while it contains active nodes" test/robot_output/log-*.html 2>/dev/null; then \
				echo "üõë Active Groundplex nodes detected ‚Äî cannot delete and create new project space..."; \
			else \
				echo "‚ùå project space creation failed for a different reason."; \
				exit 1; \
			fi; \
		}; \
	else \
		echo "‚è© Skippin project space creation(PROJECT_SPACE_SETUP is not True)"; \
		echo ":========== [Phase 1.1] Verifying if project space exists =========="; \
		$(MAKE) robot-run-tests TAGS="verify_project_space_exists" PROJECT_SPACE_SETUP=False || exit 1; \
	fi; \
	\
	echo ":========== [Phase 2] ‚è© SKIPPING Groundplex/Plex operations =========="; \
	echo "‚ÑπÔ∏è  Note: This target does not create or manage plex/groundplex"; \
	echo "‚ÑπÔ∏è  Ensure Groundplex is already running if your tests require it"; \
	\
	echo ":========== [Phase 2.1] Setting permissions for test data directories (Travis only) =========="; \
	if [ "$$TRAVIS" = "true" ]; then \
		chmod +x ./travis_scripts/set_travis_permissions.sh; \
		./travis_scripts/set_travis_permissions.sh || echo "Warning: Could not set all permissions"; \
	else \
		echo "‚ÑπÔ∏è Skipping set_travis_permissions (not running on Travis CI)"; \
	fi; \
	\
	echo ":========== [Phase 3] Running user-defined robot tests... =========="; \
	$(MAKE) robot-run-tests TAGS="$(TAGS)" PROJECT_SPACE_SETUP=False
# =============================================================================
# üì¢ Send slack notifications for test results
# =============================================================================
slack-notify:
	@echo "üìß Sending Slack notifications for test results..."
	@docker compose --env-file .env -f docker-compose.yml exec \
		-e SLACK_WEBHOOK_URL \
		-w /app/test tools \
		bash -c 'LATEST_OUTPUT=$$(ls -t robot_output/output-*.xml | head -1); \
		         echo "Processing: $$LATEST_OUTPUT"; \
		         python testresults_slack_notifications.py "$$LATEST_OUTPUT"' \
	&& echo "‚úÖ Notifications sent successfully!" \
	|| echo "‚ö†Ô∏è Failed to send notifications"



# =============================================================================
# üì§ Upload Robot Framework test results to S3
# Usage:
#   make upload-test-results                     # Upload all files with zip
#   CREATE_ZIP=false make upload-test-results    # Upload without zip file
#   UPLOAD_LATEST_ONLY=true make upload-test-results  # Upload only latest files
# =============================================================================
upload-test-results:
	@echo "‚òÅÔ∏è Uploading test results to S3..."
	@echo "üîç Checking for AWS credentials..."
	@if [ -z "$AWS_ACCESS_KEY_ID" ] || [ -z "$AWS_SECRET_ACCESS_KEY" ]; then \
		echo "‚ö†Ô∏è  AWS credentials not found in environment."; \
		echo "üîç Checking .env file for credentials..."; \
		if [ -f ".env" ] && grep -q "AWS_ACCESS_KEY_ID" .env && grep -q "AWS_SECRET_ACCESS_KEY" .env; then \
			echo "‚úÖ Found AWS credentials in .env file"; \
			export $(cat .env | grep -E '^AWS_' | xargs); \
		else \
			echo "‚ùå AWS credentials not found. Please set:"; \
			echo "   export AWS_ACCESS_KEY_ID=your_access_key"; \
			echo "   export AWS_SECRET_ACCESS_KEY=your_secret_key"; \
			echo "   Or add them to your .env file"; \
			exit 1; \
		fi; \
	fi
	@echo "üöÄ Running upload script inside tools container..."
	$(DOCKER_COMPOSE) exec -w /app/test -e AWS_ACCESS_KEY_ID -e AWS_SECRET_ACCESS_KEY -e CREATE_ZIP -e UPLOAD_LATEST_ONLY -e LATEST_COUNT tools python upload_robot_results.py




# =============================================================================
# üì§ Export Assets From Project (Full Suite Setup)
#   ‚Üí Exports assets with full suite initialization (includes credential setup)
#   ‚Üí This runs the full suite setup which properly initializes authentication
#   ‚Üí usage: make sl-export-assets
#   ‚Üí Optional arguments:
#     PROJECT_PATH       - SnapLogic project path to export from
#     ASSET_TYPES        - Types of assets to export: All, Pipeline, Account, File (default: All)
#     EXPORT_FILE_NAME   - Custom ZIP filename
#   ‚Üí Examples:
#     make sl-export-assets
#     make sl-export-assets PROJECT_PATH="swapna-automation-latest/sl_project" EXPORT_FILE_NAME="prod_backup.zip"
# =============================================================================
sl-export-assets: check-env
	@echo "üì§ Exporting assets from SnapLogic project (with full suite initialization)..."
	$(eval ORG_NAME_VALUE := $(shell grep -E '^ORG_NAME=' .env | cut -d '=' -f 2))
	$(eval ROBOT_VARS := )
	$(if $(PROJECT_PATH),$(eval ROBOT_VARS += --variable PROJECT_PATH:$(PROJECT_PATH)))
	$(if $(ASSET_TYPES),$(eval ROBOT_VARS += --variable ASSET_TYPES:$(ASSET_TYPES)))
	$(if $(EXPORT_FILE_NAME),$(eval ROBOT_VARS += --variable EXPORT_FILE_NAME:$(EXPORT_FILE_NAME)))
	@echo "‚ÑπÔ∏è  Organization: $(ORG_NAME_VALUE)"
	@if [ -n "$(PROJECT_PATH)" ]; then echo "‚ÑπÔ∏è  Project Path: $(PROJECT_PATH)"; fi
	@if [ -n "$(ASSET_TYPES)" ]; then echo "‚ÑπÔ∏è  Asset Types: $(ASSET_TYPES)"; fi
	@if [ -n "$(EXPORT_FILE_NAME)" ]; then echo "‚ÑπÔ∏è  Export File: $(EXPORT_FILE_NAME)"; fi
	@$(DOCKER_COMPOSE) exec -w /app/test tools robot \
		--include export_assets \
		--outputdir robot_output \
		$(ROBOT_VARS) \
		suite/ && \
	echo "‚úÖ Assets exported successfully!" || \
	echo "‚ùå Export failed. Check the logs for details."

# =============================================================================
# üì• Import Assets To Project (Full Suite Setup)
#   ‚Üí Imports assets with full suite initialization (includes credential setup)
#   ‚Üí This runs the full suite setup which properly initializes authentication
#   ‚Üí usage: make sl-import-assets
#   ‚Üí Optional arguments:
#     IMPORT_PATH          - Target path in SnapLogic where assets will be imported
#     ZIP_FILE_PATH        - Local path to the backup ZIP file to import
#     DUPLICATE_CHECK      - Whether to check for duplicate assets: true or false (default: false)
#     PROJECT_SPACE_SETUP  - Whether to delete/recreate project space: True or False (default: False)
#   ‚Üí Usage Examples:
#     make sl-import-assets IMPORT_PATH="swapna-automation-latest/test2" ZIP_FILE_PATH="src/exported_assets/prod_backup.zip"
# =============================================================================
sl-import-assets: check-env
	@echo "üì• Importing assets to SnapLogic project (with full suite initialization)..."
	$(eval ORG_NAME_VALUE := $(shell grep -E '^ORG_NAME=' .env | cut -d '=' -f 2))
	$(eval PROJECT_SPACE_SETUP_VAL := $(if $(PROJECT_SPACE_SETUP),$(PROJECT_SPACE_SETUP),False))
	$(eval ROBOT_VARS := --variable PROJECT_SPACE_SETUP:$(PROJECT_SPACE_SETUP_VAL))
	$(if $(IMPORT_PATH),$(eval ROBOT_VARS += --variable IMPORT_PATH:$(IMPORT_PATH)))
	$(if $(ZIP_FILE_PATH),$(eval ROBOT_VARS += --variable ZIP_FILE_PATH:$(ZIP_FILE_PATH)))
	$(if $(DUPLICATE_CHECK),$(eval ROBOT_VARS += --variable DUPLICATE_CHECK:$(DUPLICATE_CHECK)))
	@echo "‚ÑπÔ∏è  Organization: $(ORG_NAME_VALUE)"
	@echo "‚ÑπÔ∏è  Project Space Setup: $(PROJECT_SPACE_SETUP_VAL)"
	@if [ -n "$(IMPORT_PATH)" ]; then echo "‚ÑπÔ∏è  Import Path: $(IMPORT_PATH)"; fi
	@if [ -n "$(ZIP_FILE_PATH)" ]; then echo "‚ÑπÔ∏è  ZIP File: $(ZIP_FILE_PATH)"; fi
	@if [ -n "$(DUPLICATE_CHECK)" ]; then echo "‚ÑπÔ∏è  Duplicate Check: $(DUPLICATE_CHECK)"; fi
	@$(DOCKER_COMPOSE) exec -w /app/test tools robot \
		--include import_assets \
		--outputdir robot_output \
		$(ROBOT_VARS) \
		suite/ && \
	echo "‚úÖ Assets imported successfully!" || \
	echo "‚ùå Import failed. Check the logs for details."




################################################################################
# Import SLIM-generated Pipelines (.slp) into SnapLogic project
################################################################################
# üì• Import Pipeline(s) to Project
#   ‚Üí Automatically uploads ALL .slp files from GENERATIVE_SLP_PIPELINES_PATH
#   ‚Üí If PIPELINE_FILE_NAME is specified, uploads only that file
#   ‚Üí Optional arguments:
#     PIPELINE_FILE_NAME                       - Specific pipeline filename (if omitted, uploads ALL .slp files)
#     PROJECT_PATH                             - Target SnapLogic project path
#     GENERATIVE_SLP_PIPELINES_PATH - Source directory (default: src/generative_pipelines)
#     PROJECT_SPACE_SETUP                      - Delete/recreate project space: True/False (default: False)
#   
#   ‚Üí Usage Examples:
#     
#     make sl-import-pipeline \
#         PROJECT_PATH="sl_projectspace/sl_project" \
#         GENERATIVE_SLP_PIPELINES_PATH="src/generative_pipelines" \
#         PROJECT_SPACE_SETUP=True
#
#     make sl-import-pipeline \
#         PROJECT_PATH="sl_projectspace/sl_project" \
#         PROJECT_SPACE_SETUP=True

import-slim-generated-pipelines: check-env
	@echo "Importing SLIM-generated pipeline(s) into SnapLogic project..."
	@echo "================================================================="

	$(eval PROJECT_SPACE_SETUP_VAL := $(if $(PROJECT_SPACE_SETUP),$(PROJECT_SPACE_SETUP),False))

	$(eval PROJECT_PATH_VAL := \
		$(if $(PROJECT_PATH),$(PROJECT_PATH),\
			$(shell grep -E '^PROJECT_SPACE=' .env | cut -d '=' -f 2)/\
			$(shell grep -E '^PROJECT_NAME=' .env | cut -d '=' -f 2)))

	$(if $(GENERATIVE_SLP_PIPELINES_PATH),\
		$(eval RAW_PIPELINE_PATH := $(GENERATIVE_SLP_PIPELINES_PATH)),\
		$(eval RAW_PIPELINE_PATH := src/generative_pipelines))

	$(if $(filter /app/%,$(RAW_PIPELINE_PATH)),\
		$(eval NORMALIZED_PIPELINE_PATH := $(RAW_PIPELINE_PATH)),\
		$(eval NORMALIZED_PIPELINE_PATH := /app/$(RAW_PIPELINE_PATH)))

	@echo "Pipeline directory inside container: $(NORMALIZED_PIPELINE_PATH)"

	@if ! $(DOCKER_COMPOSE) exec -T tools test -d "$(NORMALIZED_PIPELINE_PATH)"; then \
		echo "ERROR: Directory $(NORMALIZED_PIPELINE_PATH) does not exist."; \
		exit 1; \
	fi

	@if [ -n "$(PIPELINE_FILE_NAME)" ]; then \
		echo "Uploading specific pipeline: $(PIPELINE_FILE_NAME)"; \
		$(DOCKER_COMPOSE) exec -T -w /app/test tools \
			robot --include upload_pipeline --outputdir robot_output \
			"--variable" "PROJECT_SPACE_SETUP:$(PROJECT_SPACE_SETUP_VAL)" \
			"--variable" "pipeline_file_name:$(PIPELINE_FILE_NAME)" \
			"--variable" "project_path:$(PROJECT_PATH_VAL)" \
			"--variable" "GENERATIVE_SLP_PIPELINES_PATH:$(NORMALIZED_PIPELINE_PATH)" \
			suite/ \
			|| (echo "Pipeline import failed." && exit 1); \
	else \
		echo "Uploading all pipelines from $(NORMALIZED_PIPELINE_PATH)"; \
		PIPELINE_FILES=$$($(DOCKER_COMPOSE) exec -T tools find $(NORMALIZED_PIPELINE_PATH) -maxdepth 1 -name "*.slp" -type f | xargs -n1 basename); \
		if [ -z "$$PIPELINE_FILES" ]; then echo "No .slp files found."; exit 1; fi; \
		TOTAL=$$(echo "$$PIPELINE_FILES" | wc -l); \
		echo "Total pipelines found: $$TOTAL"; \
		FAILED=0; \
		for FILE in $$PIPELINE_FILES; do \
			echo "Uploading $$FILE"; \
			if ! $(DOCKER_COMPOSE) exec -T -w /app/test tools \
				robot --include upload_pipeline --outputdir robot_output \
				"--variable" "PROJECT_SPACE_SETUP:$(PROJECT_SPACE_SETUP_VAL)" \
				"--variable" "pipeline_file_name:$$FILE" \
				"--variable" "project_path:$(PROJECT_PATH_VAL)" \
				"--variable" "GENERATIVE_SLP_PIPELINES_PATH:$(NORMALIZED_PIPELINE_PATH)" \
				suite/ ; then \
					FAILED=$$((FAILED + 1)); \
				fi; \
		done; \
		if [ $$FAILED -eq 0 ]; then echo "All pipelines imported successfully."; \
		else echo "$$FAILED pipelines failed to import."; fi; \
	fi